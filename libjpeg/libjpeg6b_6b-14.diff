--- libjpeg6b-6b.orig/jpegtran.1
+++ libjpeg6b-6b/jpegtran.1
@@ -91,12 +91,12 @@
 .TP
 .B \-transverse
 Transverse transpose (across UR-to-LL axis).
-.PP
+.IP
 The transpose transformation has no restrictions regarding image dimensions.
 The other transformations operate rather oddly if the image dimensions are not
 a multiple of the iMCU size (usually 8 or 16 pixels), because they can only
 transform complete blocks of DCT coefficient data in the desired way.
-.PP
+.IP
 .BR jpegtran 's
 default behavior when transforming an odd-size image is designed
 to preserve exact reversibility and mathematical consistency of the
@@ -108,7 +108,7 @@
 of transpose and flip operations; for consistency, their actions on edge
 pixels are defined to be the same as the end result of the corresponding
 transpose-and-flip sequence.
-.PP
+.IP
 For practical use, you may prefer to discard any untransformable edge pixels
 rather than having a strange-looking strip along the right and/or bottom edges
 of a transformed image.  To do this, add the
@@ -117,7 +117,7 @@
 .TP
 .B \-trim
 Drop non-transformable edge blocks.
-.PP
+.IP
 Obviously, a transformation with
 .B \-trim
 is not reversible, so strictly speaking
@@ -130,12 +130,46 @@
 followed by
 .B \-rot 180 -trim
 trims both edges.
+.IP
+If you are only interested by perfect transformation, add the
+.B \-perfect
+switch:
+.TP
+.B \-perfect
+Fails with an error if the transformation is not perfect. For example
+you may want to do
+.IP
+.B (jpegtran \-rot 90 -perfect foo.jpg || djpeg foo.jpg| pnmflip \-r90 | cjpeg)
+.IP
+to do a perfect rotation if available or an approximated one if
+not.
+.PP
+We also offer a lossless-crop option, which discards data outside a given
+image region but losslessly preserves what is inside.  Like the rotate and
+flip transforms, lossless crop is restricted by the JPEG format: the upper
+left corner of the selected region must fall on an iMCU boundary.  If this
+does not hold for the given crop parameters, we silently move the upper left
+corner up and/or left to make it so, simultaneously increasing the region
+dimensions to keep the lower right crop corner unchanged.  (Thus, the
+output image covers at least the requested region, but may cover more.)
+.IP
+Note: 
+.B \-perfect
+and
+.B lossless-crop
+are enhancements from http://sylvana.net/jpegcrop/ that may not be available on
+non-Debian systems.
+.PP
+The image can be losslessly cropped by giving the switch:
+.TP
+.B \-crop WxH+X+Y
+Crop to a rectangular subarea of width W, height H starting at point X,Y.
 .PP
 Another not-strictly-lossless transformation switch is:
 .TP
 .B \-grayscale
 Force grayscale output.
-.PP
+.IP
 This option discards the chrominance channels if the input image is YCbCr
 (ie, a standard color JPEG), resulting in a grayscale JPEG file.  The
 luminance channel is preserved exactly, so this is a better method of reducing
@@ -159,9 +193,11 @@
 .TP
 .B \-copy all
 Copy all extra markers.  This setting preserves miscellaneous markers
-found in the source file, such as JFIF thumbnails and Photoshop settings.
+found in the source file, such as
+Exif data,
+JFIF thumbnails and Photoshop settings.
 In some files these extra markers can be sizable.
-.PP
+.IP
 The default behavior is
 .BR "\-copy comments" .
 (Note: in IJG releases v6 and v6a,
@@ -231,7 +267,9 @@
 .PP
 The transform options can't transform odd-size images perfectly.  Use
 .B \-trim
-if you don't like the results without it.
+or
+.B \-perfect
+if you don't like the results.
 .PP
 The entire image is read into memory and then written out again, even in
 cases where this isn't really necessary.  Expect swapping on large images,
--- libjpeg6b-6b.orig/transupp.c
+++ libjpeg6b-6b/transupp.c
@@ -1,7 +1,7 @@
 /*
  * transupp.c
  *
- * Copyright (C) 1997, Thomas G. Lane.
+ * Copyright (C) 1997-2001, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -20,6 +20,7 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "transupp.h"		/* My own external interface */
+#include <ctype.h>		/* to declare isdigit() */
 
 
 #if TRANSFORMS_SUPPORTED
@@ -28,7 +29,8 @@
  * Lossless image transformation routines.  These routines work on DCT
  * coefficient arrays and thus do not require any lossy decompression
  * or recompression of the image.
- * Thanks to Guido Vollbeding for the initial design and code of this feature.
+ * Thanks to Guido Vollbeding for the initial design and code of this feature,
+ * and to Ben Jackson for introducing the cropping feature.
  *
  * Horizontal flipping is done in-place, using a single top-to-bottom
  * pass through the virtual source array.  It will thus be much the
@@ -42,6 +44,13 @@
  * arrays for most of the transforms.  That could result in much thrashing
  * if the image is larger than main memory.
  *
+ * If cropping or trimming is involved, the destination arrays may be smaller
+ * than the source arrays.  Note it is not possible to do horizontal flip
+ * in-place when a nonzero Y crop offset is specified, since we'd have to move
+ * data from one block row to another but the virtual array manager doesn't
+ * guarantee we can touch more than one row at a time.  So in that case,
+ * we have to use a separate destination array.
+ *
  * Some notes about the operating environment of the individual transform
  * routines:
  * 1. Both the source and destination virtual arrays are allocated from the
@@ -54,20 +63,65 @@
  *    and we may as well take that as the effective iMCU size.
  * 4. When "trim" is in effect, the destination's dimensions will be the
  *    trimmed values but the source's will be untrimmed.
- * 5. All the routines assume that the source and destination buffers are
+ * 5. When "crop" is in effect, the destination's dimensions will be the
+ *    cropped values but the source's will be uncropped.  Each transform
+ *    routine is responsible for picking up source data starting at the
+ *    correct X and Y offset for the crop region.  (The X and Y offsets
+ *    passed to the transform routines are measured in iMCU blocks of the
+ *    destination.)
+ * 6. All the routines assume that the source and destination buffers are
  *    padded out to a full iMCU boundary.  This is true, although for the
  *    source buffer it is an undocumented property of jdcoefct.c.
- * Notes 2,3,4 boil down to this: generally we should use the destination's
- * dimensions and ignore the source's.
  */
 
 
 LOCAL(void)
-do_flip_h (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	   jvirt_barray_ptr *src_coef_arrays)
-/* Horizontal flip; done in-place, so no separate dest array is required */
+do_crop (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	 JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	 jvirt_barray_ptr *src_coef_arrays,
+	 jvirt_barray_ptr *dst_coef_arrays)
+/* Crop.  This is only used when no rotate/flip is requested with the crop. */
+{
+  JDIMENSION dst_blk_y, x_crop_blocks, y_crop_blocks;
+  int ci, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  jpeg_component_info *compptr;
+
+  /* We simply have to copy the right amount of data (the destination's
+   * image size) starting at the given X and Y offsets in the source.
+   */
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      src_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	 dst_blk_y + y_crop_blocks,
+	 (JDIMENSION) compptr->v_samp_factor, FALSE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,
+			dst_buffer[offset_y],
+			compptr->width_in_blocks);
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_flip_h_no_crop (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+		   JDIMENSION x_crop_offset,
+		   jvirt_barray_ptr *src_coef_arrays)
+/* Horizontal flip; done in-place, so no separate dest array is required.
+ * NB: this only works when y_crop_offset is zero.
+ */
 {
-  JDIMENSION MCU_cols, comp_width, blk_x, blk_y;
+  JDIMENSION MCU_cols, comp_width, blk_x, blk_y, x_crop_blocks;
   int ci, k, offset_y;
   JBLOCKARRAY buffer;
   JCOEFPTR ptr1, ptr2;
@@ -79,17 +133,19 @@
    * mirroring by changing the signs of odd-numbered columns.
    * Partial iMCUs at the right edge are left untouched.
    */
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+  MCU_cols = srcinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_width = MCU_cols * compptr->h_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
     for (blk_y = 0; blk_y < compptr->height_in_blocks;
 	 blk_y += compptr->v_samp_factor) {
       buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, src_coef_arrays[ci], blk_y,
 	 (JDIMENSION) compptr->v_samp_factor, TRUE);
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	/* Do the mirroring */
 	for (blk_x = 0; blk_x * 2 < comp_width; blk_x++) {
 	  ptr1 = buffer[offset_y][blk_x];
 	  ptr2 = buffer[offset_y][comp_width - blk_x - 1];
@@ -105,6 +161,79 @@
 	    *ptr2++ = -temp1;
 	  }
 	}
+	if (x_crop_blocks > 0) {
+	  /* Now left-justify the portion of the data to be kept.
+	   * We can't use a single jcopy_block_row() call because that routine
+	   * depends on memcpy(), whose behavior is unspecified for overlapping
+	   * source and destination areas.  Sigh.
+	   */
+	  for (blk_x = 0; blk_x < compptr->width_in_blocks; blk_x++) {
+	    jcopy_block_row(buffer[offset_y] + blk_x + x_crop_blocks,
+			    buffer[offset_y] + blk_x,
+			    (JDIMENSION) 1);
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_flip_h (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	   jvirt_barray_ptr *src_coef_arrays,
+	   jvirt_barray_ptr *dst_coef_arrays)
+/* Horizontal flip in general cropping case */
+{
+  JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
+  int ci, k, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JBLOCKROW src_row_ptr, dst_row_ptr;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* Here we must output into a separate array because we can't touch
+   * different rows of a single virtual array simultaneously.  Otherwise,
+   * this is essentially the same as the routine above.
+   */
+  MCU_cols = srcinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      src_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	 dst_blk_y + y_crop_blocks,
+	 (JDIMENSION) compptr->v_samp_factor, FALSE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	dst_row_ptr = dst_buffer[offset_y];
+	src_row_ptr = src_buffer[offset_y];
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+	  if (x_crop_blocks + dst_blk_x < comp_width) {
+	    /* Do the mirrorable blocks */
+	    dst_ptr = dst_row_ptr[dst_blk_x];
+	    src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
+	    /* this unrolled loop doesn't need to know which row it's on... */
+	    for (k = 0; k < DCTSIZE2; k += 2) {
+	      *dst_ptr++ = *src_ptr++;	 /* copy even column */
+	      *dst_ptr++ = - *src_ptr++; /* copy odd column with sign change */
+	    }
+	  } else {
+	    /* Copy last partial block(s) verbatim */
+	    jcopy_block_row(src_row_ptr + dst_blk_x + x_crop_blocks,
+			    dst_row_ptr + dst_blk_x,
+			    (JDIMENSION) 1);
+	  }
+	}
       }
     }
   }
@@ -113,11 +242,13 @@
 
 LOCAL(void)
 do_flip_v (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	   jvirt_barray_ptr *src_coef_arrays,
 	   jvirt_barray_ptr *dst_coef_arrays)
 /* Vertical flip */
 {
   JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JBLOCKROW src_row_ptr, dst_row_ptr;
@@ -131,33 +262,38 @@
    * of odd-numbered rows.
    * Partial iMCUs at the bottom edge are copied verbatim.
    */
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+  MCU_rows = srcinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
 	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      if (dst_blk_y < comp_height) {
+      if (y_crop_blocks + dst_blk_y < comp_height) {
 	/* Row is within the mirrorable area. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
 	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
-	   comp_height - dst_blk_y - (JDIMENSION) compptr->v_samp_factor,
+	   comp_height - y_crop_blocks - dst_blk_y -
+	   (JDIMENSION) compptr->v_samp_factor,
 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
       } else {
 	/* Bottom-edge blocks will be copied verbatim. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
-	  ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_y,
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	   dst_blk_y + y_crop_blocks,
 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
       }
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	if (dst_blk_y < comp_height) {
+	if (y_crop_blocks + dst_blk_y < comp_height) {
 	  /* Row is within the mirrorable area. */
 	  dst_row_ptr = dst_buffer[offset_y];
 	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
+	  src_row_ptr += x_crop_blocks;
 	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	       dst_blk_x++) {
 	    dst_ptr = dst_row_ptr[dst_blk_x];
@@ -173,7 +309,8 @@
 	  }
 	} else {
 	  /* Just copy row verbatim. */
-	  jcopy_block_row(src_buffer[offset_y], dst_buffer[offset_y],
+	  jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,
+			  dst_buffer[offset_y],
 			  compptr->width_in_blocks);
 	}
       }
@@ -184,11 +321,12 @@
 
 LOCAL(void)
 do_transpose (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	      JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	      jvirt_barray_ptr *src_coef_arrays,
 	      jvirt_barray_ptr *dst_coef_arrays)
 /* Transpose source into destination */
 {
-  JDIMENSION dst_blk_x, dst_blk_y;
+  JDIMENSION dst_blk_x, dst_blk_y, x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_x, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JCOEFPTR src_ptr, dst_ptr;
@@ -201,6 +339,8 @@
    */
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
@@ -210,11 +350,12 @@
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
 	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
+	    ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	     dst_blk_x + x_crop_blocks,
 	     (JDIMENSION) compptr->h_samp_factor, FALSE);
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
-	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
 	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y + y_crop_blocks];
 	    for (i = 0; i < DCTSIZE; i++)
 	      for (j = 0; j < DCTSIZE; j++)
 		dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -228,6 +369,7 @@
 
 LOCAL(void)
 do_rot_90 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	   jvirt_barray_ptr *src_coef_arrays,
 	   jvirt_barray_ptr *dst_coef_arrays)
 /* 90 degree rotation is equivalent to
@@ -237,6 +379,7 @@
  */
 {
   JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_x, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JCOEFPTR src_ptr, dst_ptr;
@@ -246,11 +389,13 @@
    * at the (output) right edge properly.  They just get transposed and
    * not mirrored.
    */
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+  MCU_cols = srcinfo->image_height / (dstinfo->max_h_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_width = MCU_cols * compptr->h_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
@@ -259,15 +404,26 @@
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
-	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
-	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  if (x_crop_blocks + dst_blk_x < comp_width) {
+	    /* Block is within the mirrorable area. */
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       comp_width - x_crop_blocks - dst_blk_x -
+	       (JDIMENSION) compptr->h_samp_factor,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  } else {
+	    /* Edge blocks are transposed but not mirrored. */
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       dst_blk_x + x_crop_blocks,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  }
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
-	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
-	    if (dst_blk_x < comp_width) {
+	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    if (x_crop_blocks + dst_blk_x < comp_width) {
 	      /* Block is within the mirrorable area. */
-	      dst_ptr = dst_buffer[offset_y]
-		[comp_width - dst_blk_x - offset_x - 1];
+	      src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
+		[dst_blk_y + offset_y + y_crop_blocks];
 	      for (i = 0; i < DCTSIZE; i++) {
 		for (j = 0; j < DCTSIZE; j++)
 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -277,7 +433,8 @@
 	      }
 	    } else {
 	      /* Edge blocks are transposed but not mirrored. */
-	      dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	      src_ptr = src_buffer[offset_x]
+		[dst_blk_y + offset_y + y_crop_blocks];
 	      for (i = 0; i < DCTSIZE; i++)
 		for (j = 0; j < DCTSIZE; j++)
 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -292,6 +449,7 @@
 
 LOCAL(void)
 do_rot_270 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	    JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	    jvirt_barray_ptr *src_coef_arrays,
 	    jvirt_barray_ptr *dst_coef_arrays)
 /* 270 degree rotation is equivalent to
@@ -301,6 +459,7 @@
  */
 {
   JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_x, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JCOEFPTR src_ptr, dst_ptr;
@@ -310,11 +469,13 @@
    * at the (output) bottom edge properly.  They just get transposed and
    * not mirrored.
    */
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+  MCU_rows = srcinfo->image_width / (dstinfo->max_v_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
@@ -324,14 +485,15 @@
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
 	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
+	    ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	     dst_blk_x + x_crop_blocks,
 	     (JDIMENSION) compptr->h_samp_factor, FALSE);
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
 	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
-	    if (dst_blk_y < comp_height) {
+	    if (y_crop_blocks + dst_blk_y < comp_height) {
 	      /* Block is within the mirrorable area. */
 	      src_ptr = src_buffer[offset_x]
-		[comp_height - dst_blk_y - offset_y - 1];
+		[comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
 	      for (i = 0; i < DCTSIZE; i++) {
 		for (j = 0; j < DCTSIZE; j++) {
 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -341,7 +503,8 @@
 	      }
 	    } else {
 	      /* Edge blocks are transposed but not mirrored. */
-	      src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
+	      src_ptr = src_buffer[offset_x]
+		[dst_blk_y + offset_y + y_crop_blocks];
 	      for (i = 0; i < DCTSIZE; i++)
 		for (j = 0; j < DCTSIZE; j++)
 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -356,6 +519,7 @@
 
 LOCAL(void)
 do_rot_180 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	    JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	    jvirt_barray_ptr *src_coef_arrays,
 	    jvirt_barray_ptr *dst_coef_arrays)
 /* 180 degree rotation is equivalent to
@@ -365,89 +529,93 @@
  */
 {
   JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JBLOCKROW src_row_ptr, dst_row_ptr;
   JCOEFPTR src_ptr, dst_ptr;
   jpeg_component_info *compptr;
 
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+  MCU_cols = srcinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+  MCU_rows = srcinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_width = MCU_cols * compptr->h_samp_factor;
     comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
 	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      if (dst_blk_y < comp_height) {
+      if (y_crop_blocks + dst_blk_y < comp_height) {
 	/* Row is within the vertically mirrorable area. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
 	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
-	   comp_height - dst_blk_y - (JDIMENSION) compptr->v_samp_factor,
+	   comp_height - y_crop_blocks - dst_blk_y -
+	   (JDIMENSION) compptr->v_samp_factor,
 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
       } else {
 	/* Bottom-edge rows are only mirrored horizontally. */
 	src_buffer = (*srcinfo->mem->access_virt_barray)
-	  ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_y,
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	   dst_blk_y + y_crop_blocks,
 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
       }
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	if (dst_blk_y < comp_height) {
+	dst_row_ptr = dst_buffer[offset_y];
+	if (y_crop_blocks + dst_blk_y < comp_height) {
 	  /* Row is within the mirrorable area. */
-	  dst_row_ptr = dst_buffer[offset_y];
 	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
-	  /* Process the blocks that can be mirrored both ways. */
-	  for (dst_blk_x = 0; dst_blk_x < comp_width; dst_blk_x++) {
+	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
 	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[comp_width - dst_blk_x - 1];
-	    for (i = 0; i < DCTSIZE; i += 2) {
-	      /* For even row, negate every odd column. */
-	      for (j = 0; j < DCTSIZE; j += 2) {
-		*dst_ptr++ = *src_ptr++;
-		*dst_ptr++ = - *src_ptr++;
+	    if (x_crop_blocks + dst_blk_x < comp_width) {
+	      /* Process the blocks that can be mirrored both ways. */
+	      src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
+	      for (i = 0; i < DCTSIZE; i += 2) {
+		/* For even row, negate every odd column. */
+		for (j = 0; j < DCTSIZE; j += 2) {
+		  *dst_ptr++ = *src_ptr++;
+		  *dst_ptr++ = - *src_ptr++;
+		}
+		/* For odd row, negate every even column. */
+		for (j = 0; j < DCTSIZE; j += 2) {
+		  *dst_ptr++ = - *src_ptr++;
+		  *dst_ptr++ = *src_ptr++;
+		}
 	      }
-	      /* For odd row, negate every even column. */
-	      for (j = 0; j < DCTSIZE; j += 2) {
-		*dst_ptr++ = - *src_ptr++;
-		*dst_ptr++ = *src_ptr++;
+	    } else {
+	      /* Any remaining right-edge blocks are only mirrored vertically. */
+	      src_ptr = src_row_ptr[x_crop_blocks + dst_blk_x];
+	      for (i = 0; i < DCTSIZE; i += 2) {
+		for (j = 0; j < DCTSIZE; j++)
+		  *dst_ptr++ = *src_ptr++;
+		for (j = 0; j < DCTSIZE; j++)
+		  *dst_ptr++ = - *src_ptr++;
 	      }
 	    }
 	  }
-	  /* Any remaining right-edge blocks are only mirrored vertically. */
-	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[dst_blk_x];
-	    for (i = 0; i < DCTSIZE; i += 2) {
-	      for (j = 0; j < DCTSIZE; j++)
-		*dst_ptr++ = *src_ptr++;
-	      for (j = 0; j < DCTSIZE; j++)
-		*dst_ptr++ = - *src_ptr++;
-	    }
-	  }
 	} else {
 	  /* Remaining rows are just mirrored horizontally. */
-	  dst_row_ptr = dst_buffer[offset_y];
 	  src_row_ptr = src_buffer[offset_y];
-	  /* Process the blocks that can be mirrored. */
-	  for (dst_blk_x = 0; dst_blk_x < comp_width; dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[comp_width - dst_blk_x - 1];
-	    for (i = 0; i < DCTSIZE2; i += 2) {
-	      *dst_ptr++ = *src_ptr++;
-	      *dst_ptr++ = - *src_ptr++;
+	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+	    if (x_crop_blocks + dst_blk_x < comp_width) {
+	      /* Process the blocks that can be mirrored. */
+	      dst_ptr = dst_row_ptr[dst_blk_x];
+	      src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
+	      for (i = 0; i < DCTSIZE2; i += 2) {
+		*dst_ptr++ = *src_ptr++;
+		*dst_ptr++ = - *src_ptr++;
+	      }
+	    } else {
+	      /* Any remaining right-edge blocks are only copied. */
+	      jcopy_block_row(src_row_ptr + dst_blk_x + x_crop_blocks,
+			      dst_row_ptr + dst_blk_x,
+			      (JDIMENSION) 1);
 	    }
 	  }
-	  /* Any remaining right-edge blocks are only copied. */
-	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[dst_blk_x];
-	    for (i = 0; i < DCTSIZE2; i++)
-	      *dst_ptr++ = *src_ptr++;
-	  }
 	}
       }
     }
@@ -457,6 +625,7 @@
 
 LOCAL(void)
 do_transverse (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	       JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
 	       jvirt_barray_ptr *src_coef_arrays,
 	       jvirt_barray_ptr *dst_coef_arrays)
 /* Transverse transpose is equivalent to
@@ -470,18 +639,21 @@
  */
 {
   JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
   int ci, i, j, offset_x, offset_y;
   JBLOCKARRAY src_buffer, dst_buffer;
   JCOEFPTR src_ptr, dst_ptr;
   jpeg_component_info *compptr;
 
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+  MCU_cols = srcinfo->image_height / (dstinfo->max_h_samp_factor * DCTSIZE);
+  MCU_rows = srcinfo->image_width / (dstinfo->max_v_samp_factor * DCTSIZE);
 
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
     comp_width = MCU_cols * compptr->h_samp_factor;
     comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
 	 dst_blk_y += compptr->v_samp_factor) {
       dst_buffer = (*srcinfo->mem->access_virt_barray)
@@ -490,17 +662,26 @@
       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
 	     dst_blk_x += compptr->h_samp_factor) {
-	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
-	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  if (x_crop_blocks + dst_blk_x < comp_width) {
+	    /* Block is within the mirrorable area. */
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       comp_width - x_crop_blocks - dst_blk_x -
+	       (JDIMENSION) compptr->h_samp_factor,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  } else {
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       dst_blk_x + x_crop_blocks,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  }
 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
-	    if (dst_blk_y < comp_height) {
-	      src_ptr = src_buffer[offset_x]
-		[comp_height - dst_blk_y - offset_y - 1];
-	      if (dst_blk_x < comp_width) {
+	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    if (y_crop_blocks + dst_blk_y < comp_height) {
+	      if (x_crop_blocks + dst_blk_x < comp_width) {
 		/* Block is within the mirrorable area. */
-		dst_ptr = dst_buffer[offset_y]
-		  [comp_width - dst_blk_x - offset_x - 1];
+		src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
+		  [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
 		for (i = 0; i < DCTSIZE; i++) {
 		  for (j = 0; j < DCTSIZE; j++) {
 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -516,7 +697,8 @@
 		}
 	      } else {
 		/* Right-edge blocks are mirrored in y only */
-		dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+		src_ptr = src_buffer[offset_x]
+		  [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
 		for (i = 0; i < DCTSIZE; i++) {
 		  for (j = 0; j < DCTSIZE; j++) {
 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -526,11 +708,10 @@
 		}
 	      }
 	    } else {
-	      src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
-	      if (dst_blk_x < comp_width) {
+	      if (x_crop_blocks + dst_blk_x < comp_width) {
 		/* Bottom-edge blocks are mirrored in x only */
-		dst_ptr = dst_buffer[offset_y]
-		  [comp_width - dst_blk_x - offset_x - 1];
+		src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
+		  [dst_blk_y + offset_y + y_crop_blocks];
 		for (i = 0; i < DCTSIZE; i++) {
 		  for (j = 0; j < DCTSIZE; j++)
 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -540,7 +721,8 @@
 		}
 	      } else {
 		/* At lower right corner, just transpose, no mirroring */
-		dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+		src_ptr = src_buffer[offset_x]
+		  [dst_blk_y + offset_y + y_crop_blocks];
 		for (i = 0; i < DCTSIZE; i++)
 		  for (j = 0; j < DCTSIZE; j++)
 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
@@ -554,8 +736,116 @@
 }
 
 
+/* Parse an unsigned integer: subroutine for jtransform_parse_crop_spec.
+ * Returns TRUE if valid integer found, FALSE if not.
+ * *strptr is advanced over the digit string, and *result is set to its value.
+ */
+
+LOCAL(boolean)
+jt_read_integer (const char ** strptr, JDIMENSION * result)
+{
+  const char * ptr = *strptr;
+  JDIMENSION val = 0;
+
+  for (; isdigit(*ptr); ptr++) {
+    val = val * 10 + (JDIMENSION) (*ptr - '0');
+  }
+  *result = val;
+  if (ptr == *strptr)
+    return FALSE;		/* oops, no digits */
+  *strptr = ptr;
+  return TRUE;
+}
+
+
+/* Parse a crop specification (written in X11 geometry style).
+ * The routine returns TRUE if the spec string is valid, FALSE if not.
+ *
+ * The crop spec string should have the format
+ *	<width>x<height>{+-}<xoffset>{+-}<yoffset>
+ * where width, height, xoffset, and yoffset are unsigned integers.
+ * Each of the elements can be omitted to indicate a default value.
+ * (A weakness of this style is that it is not possible to omit xoffset
+ * while specifying yoffset, since they look alike.)
+ *
+ * This code is loosely based on XParseGeometry from the X11 distribution.
+ */
+
+GLOBAL(boolean)
+jtransform_parse_crop_spec (jpeg_transform_info *info, const char *spec)
+{
+  info->crop = FALSE;
+  info->crop_width_set = JCROP_UNSET;
+  info->crop_height_set = JCROP_UNSET;
+  info->crop_xoffset_set = JCROP_UNSET;
+  info->crop_yoffset_set = JCROP_UNSET;
+
+  if (isdigit(*spec)) {
+    /* fetch width */
+    if (! jt_read_integer(&spec, &info->crop_width))
+      return FALSE;
+    info->crop_width_set = JCROP_POS;
+  }
+  if (*spec == 'x' || *spec == 'X') {	
+    /* fetch height */
+    spec++;
+    if (! jt_read_integer(&spec, &info->crop_height))
+      return FALSE;
+    info->crop_height_set = JCROP_POS;
+  }
+  if (*spec == '+' || *spec == '-') {
+    /* fetch xoffset */
+    info->crop_xoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;
+    spec++;
+    if (! jt_read_integer(&spec, &info->crop_xoffset))
+      return FALSE;
+  }
+  if (*spec == '+' || *spec == '-') {
+    /* fetch yoffset */
+    info->crop_yoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;
+    spec++;
+    if (! jt_read_integer(&spec, &info->crop_yoffset))
+      return FALSE;
+  }
+  /* We had better have gotten to the end of the string. */
+  if (*spec != '\0')
+    return FALSE;
+  info->crop = TRUE;
+  return TRUE;
+}
+
+
+/* Trim off any partial iMCUs on the indicated destination edge */
+
+LOCAL(void)
+trim_right_edge (jpeg_transform_info *info, JDIMENSION full_width)
+{
+  JDIMENSION MCU_cols;
+
+  MCU_cols = info->output_width / (info->max_h_samp_factor * DCTSIZE);
+  if (MCU_cols > 0 && info->x_crop_offset + MCU_cols ==
+      full_width / (info->max_h_samp_factor * DCTSIZE))
+    info->output_width = MCU_cols * (info->max_h_samp_factor * DCTSIZE);
+}
+
+LOCAL(void)
+trim_bottom_edge (jpeg_transform_info *info, JDIMENSION full_height)
+{
+  JDIMENSION MCU_rows;
+
+  MCU_rows = info->output_height / (info->max_v_samp_factor * DCTSIZE);
+  if (MCU_rows > 0 && info->y_crop_offset + MCU_rows ==
+      full_height / (info->max_v_samp_factor * DCTSIZE))
+    info->output_height = MCU_rows * (info->max_v_samp_factor * DCTSIZE);
+}
+
+
 /* Request any required workspace.
  *
+ * This routine figures out the size that the output image will be
+ * (which implies that all the transform parameters must be set before
+ * it is called).
+ *
  * We allocate the workspace virtual arrays from the source decompression
  * object, so that all the arrays (both the original data and the workspace)
  * will be taken into account while making memory management decisions.
@@ -569,9 +859,13 @@
 			      jpeg_transform_info *info)
 {
   jvirt_barray_ptr *coef_arrays = NULL;
+  boolean need_workspace, transpose_it;
   jpeg_component_info *compptr;
-  int ci;
+  JDIMENSION xoffset, yoffset, width_in_iMCUs, height_in_iMCUs;
+  JDIMENSION width_in_blocks, height_in_blocks;
+  int ci, h_samp_factor, v_samp_factor;
 
+  /* Determine number of components in output image */
   if (info->force_grayscale &&
       srcinfo->jpeg_color_space == JCS_YCbCr &&
       srcinfo->num_components == 3) {
@@ -581,55 +875,181 @@
     /* Process all the components */
     info->num_components = srcinfo->num_components;
   }
+  /* If there is only one output component, force the iMCU size to be 1;
+   * else use the source iMCU size.  (This allows us to do the right thing
+   * when reducing color to grayscale, and also provides a handy way of
+   * cleaning up "funny" grayscale images whose sampling factors are not 1x1.)
+   */
+
+  switch (info->transform) {
+  case JXFORM_TRANSPOSE:
+  case JXFORM_TRANSVERSE:
+  case JXFORM_ROT_90:
+  case JXFORM_ROT_270:
+    info->output_width = srcinfo->image_height;
+    info->output_height = srcinfo->image_width;
+    if (info->num_components == 1) {
+      info->max_h_samp_factor = 1;
+      info->max_v_samp_factor = 1;
+    } else {
+      info->max_h_samp_factor = srcinfo->max_v_samp_factor;
+      info->max_v_samp_factor = srcinfo->max_h_samp_factor;
+    }
+    break;
+  default:
+    info->output_width = srcinfo->image_width;
+    info->output_height = srcinfo->image_height;
+    if (info->num_components == 1) {
+      info->max_h_samp_factor = 1;
+      info->max_v_samp_factor = 1;
+    } else {
+      info->max_h_samp_factor = srcinfo->max_h_samp_factor;
+      info->max_v_samp_factor = srcinfo->max_v_samp_factor;
+    }
+    break;
+  }
+
+  /* If cropping has been requested, compute the crop area's position and
+   * dimensions, ensuring that its upper left corner falls at an iMCU boundary.
+   */
+  if (info->crop) {
+    /* Insert default values for unset crop parameters */
+    if (info->crop_xoffset_set == JCROP_UNSET)
+      info->crop_xoffset = 0;	/* default to +0 */
+    if (info->crop_yoffset_set == JCROP_UNSET)
+      info->crop_yoffset = 0;	/* default to +0 */
+    if (info->crop_xoffset >= info->output_width ||
+	info->crop_yoffset >= info->output_height)
+      ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);
+    if (info->crop_width_set == JCROP_UNSET)
+      info->crop_width = info->output_width - info->crop_xoffset;
+    if (info->crop_height_set == JCROP_UNSET)
+      info->crop_height = info->output_height - info->crop_yoffset;
+    /* Ensure parameters are valid */
+    if (info->crop_width <= 0 || info->crop_width > info->output_width ||
+	info->crop_height <= 0 || info->crop_height > info->output_height ||
+	info->crop_xoffset > info->output_width - info->crop_width ||
+	info->crop_yoffset > info->output_height - info->crop_height)
+      ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);
+    /* Convert negative crop offsets into regular offsets */
+    if (info->crop_xoffset_set == JCROP_NEG)
+      xoffset = info->output_width - info->crop_width - info->crop_xoffset;
+    else
+      xoffset = info->crop_xoffset;
+    if (info->crop_yoffset_set == JCROP_NEG)
+      yoffset = info->output_height - info->crop_height - info->crop_yoffset;
+    else
+      yoffset = info->crop_yoffset;
+    /* Now adjust so that upper left corner falls at an iMCU boundary */
+    info->output_width =
+      info->crop_width + (xoffset % (info->max_h_samp_factor * DCTSIZE));
+    info->output_height =
+      info->crop_height + (yoffset % (info->max_v_samp_factor * DCTSIZE));
+    /* Save x/y offsets measured in iMCUs */
+    info->x_crop_offset = xoffset / (info->max_h_samp_factor * DCTSIZE);
+    info->y_crop_offset = yoffset / (info->max_v_samp_factor * DCTSIZE);
+  } else {
+    info->x_crop_offset = 0;
+    info->y_crop_offset = 0;
+  }
 
+  /* Figure out whether we need workspace arrays,
+   * and if so whether they are transposed relative to the source.
+   */
+  need_workspace = FALSE;
+  transpose_it = FALSE;
   switch (info->transform) {
   case JXFORM_NONE:
+    if (info->x_crop_offset != 0 || info->y_crop_offset != 0)
+      need_workspace = TRUE;
+    /* No workspace needed if neither cropping nor transforming */
+    break;
   case JXFORM_FLIP_H:
-    /* Don't need a workspace array */
+    if (info->trim)
+      trim_right_edge(info, srcinfo->image_width);
+    if (info->y_crop_offset != 0)
+      need_workspace = TRUE;
+    /* do_flip_h_no_crop doesn't need a workspace array */
     break;
   case JXFORM_FLIP_V:
-  case JXFORM_ROT_180:
-    /* Need workspace arrays having same dimensions as source image.
-     * Note that we allocate arrays padded out to the next iMCU boundary,
-     * so that transform routines need not worry about missing edge blocks.
-     */
-    coef_arrays = (jvirt_barray_ptr *)
-      (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
-	SIZEOF(jvirt_barray_ptr) * info->num_components);
-    for (ci = 0; ci < info->num_components; ci++) {
-      compptr = srcinfo->comp_info + ci;
-      coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
-	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
-	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
-				(long) compptr->h_samp_factor),
-	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
-				(long) compptr->v_samp_factor),
-	 (JDIMENSION) compptr->v_samp_factor);
-    }
+    if (info->trim)
+      trim_bottom_edge(info, srcinfo->image_height);
+    /* Need workspace arrays having same dimensions as source image. */
+    need_workspace = TRUE;
     break;
   case JXFORM_TRANSPOSE:
+    /* transpose does NOT have to trim anything */
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
   case JXFORM_TRANSVERSE:
+    if (info->trim) {
+      trim_right_edge(info, srcinfo->image_height);
+      trim_bottom_edge(info, srcinfo->image_width);
+    }
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
   case JXFORM_ROT_90:
+    if (info->trim)
+      trim_right_edge(info, srcinfo->image_height);
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
+  case JXFORM_ROT_180:
+    if (info->trim) {
+      trim_right_edge(info, srcinfo->image_width);
+      trim_bottom_edge(info, srcinfo->image_height);
+    }
+    /* Need workspace arrays having same dimensions as source image. */
+    need_workspace = TRUE;
+    break;
   case JXFORM_ROT_270:
-    /* Need workspace arrays having transposed dimensions.
-     * Note that we allocate arrays padded out to the next iMCU boundary,
-     * so that transform routines need not worry about missing edge blocks.
-     */
+    if (info->trim)
+      trim_bottom_edge(info, srcinfo->image_width);
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
+  }
+
+  /* Allocate workspace if needed.
+   * Note that we allocate arrays padded out to the next iMCU boundary,
+   * so that transform routines need not worry about missing edge blocks.
+   */
+  if (need_workspace) {
     coef_arrays = (jvirt_barray_ptr *)
       (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
-	SIZEOF(jvirt_barray_ptr) * info->num_components);
+		SIZEOF(jvirt_barray_ptr) * info->num_components);
+    width_in_iMCUs = (JDIMENSION)
+      jdiv_round_up((long) info->output_width,
+		    (long) (info->max_h_samp_factor * DCTSIZE));
+    height_in_iMCUs = (JDIMENSION)
+      jdiv_round_up((long) info->output_height,
+		    (long) (info->max_v_samp_factor * DCTSIZE));
     for (ci = 0; ci < info->num_components; ci++) {
       compptr = srcinfo->comp_info + ci;
+      if (info->num_components == 1) {
+	/* we're going to force samp factors to 1x1 in this case */
+	h_samp_factor = v_samp_factor = 1;
+      } else if (transpose_it) {
+	h_samp_factor = compptr->v_samp_factor;
+	v_samp_factor = compptr->h_samp_factor;
+      } else {
+	h_samp_factor = compptr->h_samp_factor;
+	v_samp_factor = compptr->v_samp_factor;
+      }
+      width_in_blocks = width_in_iMCUs * h_samp_factor;
+      height_in_blocks = height_in_iMCUs * v_samp_factor;
       coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
 	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
-	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
-				(long) compptr->v_samp_factor),
-	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
-				(long) compptr->h_samp_factor),
-	 (JDIMENSION) compptr->h_samp_factor);
+	 width_in_blocks, height_in_blocks, (JDIMENSION) v_samp_factor);
     }
-    break;
   }
+
   info->workspace_coef_arrays = coef_arrays;
 }
 
@@ -642,14 +1062,8 @@
   int tblno, i, j, ci, itemp;
   jpeg_component_info *compptr;
   JQUANT_TBL *qtblptr;
-  JDIMENSION dtemp;
   UINT16 qtemp;
 
-  /* Transpose basic image dimensions */
-  dtemp = dstinfo->image_width;
-  dstinfo->image_width = dstinfo->image_height;
-  dstinfo->image_height = dtemp;
-
   /* Transpose sampling factors */
   for (ci = 0; ci < dstinfo->num_components; ci++) {
     compptr = dstinfo->comp_info + ci;
@@ -674,46 +1088,159 @@
 }
 
 
-/* Trim off any partial iMCUs on the indicated destination edge */
+/* Adjust Exif image parameters.
+ *
+ * We try to adjust the Tags ExifImageWidth and ExifImageHeight if possible.
+ */
 
 LOCAL(void)
-trim_right_edge (j_compress_ptr dstinfo)
+adjust_exif_parameters (JOCTET FAR * data, unsigned int length,
+			JDIMENSION new_width, JDIMENSION new_height)
 {
-  int ci, max_h_samp_factor;
-  JDIMENSION MCU_cols;
+  boolean is_motorola; /* Flag for byte order */
+  unsigned int number_of_tags, tagnum;
+  unsigned int firstoffset, offset;
+  JDIMENSION new_value;
+
+  if (length < 12) return; /* Length of an IFD entry */
+
+  /* Discover byte order */
+  if (GETJOCTET(data[0]) == 0x49 && GETJOCTET(data[1]) == 0x49)
+    is_motorola = FALSE;
+  else if (GETJOCTET(data[0]) == 0x4D && GETJOCTET(data[1]) == 0x4D)
+    is_motorola = TRUE;
+  else
+    return;
+
+  /* Check Tag Mark */
+  if (is_motorola) {
+    if (GETJOCTET(data[2]) != 0) return;
+    if (GETJOCTET(data[3]) != 0x2A) return;
+  } else {
+    if (GETJOCTET(data[3]) != 0) return;
+    if (GETJOCTET(data[2]) != 0x2A) return;
+  }
 
-  /* We have to compute max_h_samp_factor ourselves,
-   * because it hasn't been set yet in the destination
-   * (and we don't want to use the source's value).
-   */
-  max_h_samp_factor = 1;
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    int h_samp_factor = dstinfo->comp_info[ci].h_samp_factor;
-    max_h_samp_factor = MAX(max_h_samp_factor, h_samp_factor);
+  /* Get first IFD offset (offset to IFD0) */
+  if (is_motorola) {
+    if (GETJOCTET(data[4]) != 0) return;
+    if (GETJOCTET(data[5]) != 0) return;
+    firstoffset = GETJOCTET(data[6]);
+    firstoffset <<= 8;
+    firstoffset += GETJOCTET(data[7]);
+  } else {
+    if (GETJOCTET(data[7]) != 0) return;
+    if (GETJOCTET(data[6]) != 0) return;
+    firstoffset = GETJOCTET(data[5]);
+    firstoffset <<= 8;
+    firstoffset += GETJOCTET(data[4]);
   }
-  MCU_cols = dstinfo->image_width / (max_h_samp_factor * DCTSIZE);
-  if (MCU_cols > 0)		/* can't trim to 0 pixels */
-    dstinfo->image_width = MCU_cols * (max_h_samp_factor * DCTSIZE);
-}
+  if (firstoffset > length - 2) return; /* check end of data segment */
 
-LOCAL(void)
-trim_bottom_edge (j_compress_ptr dstinfo)
-{
-  int ci, max_v_samp_factor;
-  JDIMENSION MCU_rows;
+  /* Get the number of directory entries contained in this IFD */
+  if (is_motorola) {
+    number_of_tags = GETJOCTET(data[firstoffset]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[firstoffset+1]);
+  } else {
+    number_of_tags = GETJOCTET(data[firstoffset+1]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[firstoffset]);
+  }
+  if (number_of_tags == 0) return;
+  firstoffset += 2;
 
-  /* We have to compute max_v_samp_factor ourselves,
-   * because it hasn't been set yet in the destination
-   * (and we don't want to use the source's value).
-   */
-  max_v_samp_factor = 1;
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    int v_samp_factor = dstinfo->comp_info[ci].v_samp_factor;
-    max_v_samp_factor = MAX(max_v_samp_factor, v_samp_factor);
+  /* Search for ExifSubIFD offset Tag in IFD0 */
+  for (;;) {
+    if (firstoffset > length - 12) return; /* check end of data segment */
+    /* Get Tag number */
+    if (is_motorola) {
+      tagnum = GETJOCTET(data[firstoffset]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[firstoffset+1]);
+    } else {
+      tagnum = GETJOCTET(data[firstoffset+1]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[firstoffset]);
+    }
+    if (tagnum == 0x8769) break; /* found ExifSubIFD offset Tag */
+    if (--number_of_tags == 0) return;
+    firstoffset += 12;
   }
-  MCU_rows = dstinfo->image_height / (max_v_samp_factor * DCTSIZE);
-  if (MCU_rows > 0)		/* can't trim to 0 pixels */
-    dstinfo->image_height = MCU_rows * (max_v_samp_factor * DCTSIZE);
+
+  /* Get the ExifSubIFD offset */
+  if (is_motorola) {
+    if (GETJOCTET(data[firstoffset+8]) != 0) return;
+    if (GETJOCTET(data[firstoffset+9]) != 0) return;
+    offset = GETJOCTET(data[firstoffset+10]);
+    offset <<= 8;
+    offset += GETJOCTET(data[firstoffset+11]);
+  } else {
+    if (GETJOCTET(data[firstoffset+11]) != 0) return;
+    if (GETJOCTET(data[firstoffset+10]) != 0) return;
+    offset = GETJOCTET(data[firstoffset+9]);
+    offset <<= 8;
+    offset += GETJOCTET(data[firstoffset+8]);
+  }
+  if (offset > length - 2) return; /* check end of data segment */
+
+  /* Get the number of directory entries contained in this SubIFD */
+  if (is_motorola) {
+    number_of_tags = GETJOCTET(data[offset]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[offset+1]);
+  } else {
+    number_of_tags = GETJOCTET(data[offset+1]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[offset]);
+  }
+  if (number_of_tags < 2) return;
+  offset += 2;
+
+  /* Search for ExifImageWidth and ExifImageHeight Tags in this SubIFD */
+  do {
+    if (offset > length - 12) return; /* check end of data segment */
+    /* Get Tag number */
+    if (is_motorola) {
+      tagnum = GETJOCTET(data[offset]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[offset+1]);
+    } else {
+      tagnum = GETJOCTET(data[offset+1]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[offset]);
+    }
+    if (tagnum == 0xA002 || tagnum == 0xA003) {
+      if (tagnum == 0xA002)
+	new_value = new_width; /* ExifImageWidth Tag */
+      else
+	new_value = new_height; /* ExifImageHeight Tag */
+      if (is_motorola) {
+	data[offset+2] = 0; /* Format = unsigned long (4 octets) */
+	data[offset+3] = 4;
+	data[offset+4] = 0; /* Number Of Components = 1 */
+	data[offset+5] = 0;
+	data[offset+6] = 0;
+	data[offset+7] = 1;
+	data[offset+8] = 0;
+	data[offset+9] = 0;
+	data[offset+10] = (JOCTET)((new_value >> 8) & 0xFF);
+	data[offset+11] = (JOCTET)(new_value & 0xFF);
+      } else {
+	data[offset+2] = 4; /* Format = unsigned long (4 octets) */
+	data[offset+3] = 0;
+	data[offset+4] = 1; /* Number Of Components = 1 */
+	data[offset+5] = 0;
+	data[offset+6] = 0;
+	data[offset+7] = 0;
+	data[offset+8] = (JOCTET)(new_value & 0xFF);
+	data[offset+9] = (JOCTET)((new_value >> 8) & 0xFF);
+	data[offset+10] = 0;
+	data[offset+11] = 0;
+      }
+    }
+    offset += 12;
+  } while (--number_of_tags);
 }
 
 
@@ -736,18 +1263,22 @@
 {
   /* If force-to-grayscale is requested, adjust destination parameters */
   if (info->force_grayscale) {
-    /* We use jpeg_set_colorspace to make sure subsidiary settings get fixed
-     * properly.  Among other things, the target h_samp_factor & v_samp_factor
-     * will get set to 1, which typically won't match the source.
-     * In fact we do this even if the source is already grayscale; that
-     * provides an easy way of coercing a grayscale JPEG with funny sampling
-     * factors to the customary 1,1.  (Some decoders fail on other factors.)
+    /* First, ensure we have YCbCr or grayscale data, and that the source's
+     * Y channel is full resolution.  (No reasonable person would make Y
+     * be less than full resolution, so actually coping with that case
+     * isn't worth extra code space.  But we check it to avoid crashing.)
      */
-    if ((dstinfo->jpeg_color_space == JCS_YCbCr &&
-	 dstinfo->num_components == 3) ||
-	(dstinfo->jpeg_color_space == JCS_GRAYSCALE &&
-	 dstinfo->num_components == 1)) {
-      /* We have to preserve the source's quantization table number. */
+    if (((dstinfo->jpeg_color_space == JCS_YCbCr &&
+	  dstinfo->num_components == 3) ||
+	 (dstinfo->jpeg_color_space == JCS_GRAYSCALE &&
+	  dstinfo->num_components == 1)) &&
+	srcinfo->comp_info[0].h_samp_factor == srcinfo->max_h_samp_factor &&
+	srcinfo->comp_info[0].v_samp_factor == srcinfo->max_v_samp_factor) {
+      /* We use jpeg_set_colorspace to make sure subsidiary settings get fixed
+       * properly.  Among other things, it sets the target h_samp_factor &
+       * v_samp_factor to 1, which typically won't match the source.
+       * We have to preserve the source's quantization table number, however.
+       */
       int sv_quant_tbl_no = dstinfo->comp_info[0].quant_tbl_no;
       jpeg_set_colorspace(dstinfo, JCS_GRAYSCALE);
       dstinfo->comp_info[0].quant_tbl_no = sv_quant_tbl_no;
@@ -755,50 +1286,52 @@
       /* Sorry, can't do it */
       ERREXIT(dstinfo, JERR_CONVERSION_NOTIMPL);
     }
+  } else if (info->num_components == 1) {
+    /* For a single-component source, we force the destination sampling factors
+     * to 1x1, with or without force_grayscale.  This is useful because some
+     * decoders choke on grayscale images with other sampling factors.
+     */
+    dstinfo->comp_info[0].h_samp_factor = 1;
+    dstinfo->comp_info[0].v_samp_factor = 1;
   }
 
-  /* Correct the destination's image dimensions etc if necessary */
+  /* Correct the destination's image dimensions as necessary
+   * for crop and rotate/flip operations.
+   */
+  dstinfo->image_width = info->output_width;
+  dstinfo->image_height = info->output_height;
+
+  /* Transpose destination image parameters */
   switch (info->transform) {
-  case JXFORM_NONE:
-    /* Nothing to do */
-    break;
-  case JXFORM_FLIP_H:
-    if (info->trim)
-      trim_right_edge(dstinfo);
-    break;
-  case JXFORM_FLIP_V:
-    if (info->trim)
-      trim_bottom_edge(dstinfo);
-    break;
   case JXFORM_TRANSPOSE:
-    transpose_critical_parameters(dstinfo);
-    /* transpose does NOT have to trim anything */
-    break;
   case JXFORM_TRANSVERSE:
-    transpose_critical_parameters(dstinfo);
-    if (info->trim) {
-      trim_right_edge(dstinfo);
-      trim_bottom_edge(dstinfo);
-    }
-    break;
   case JXFORM_ROT_90:
-    transpose_critical_parameters(dstinfo);
-    if (info->trim)
-      trim_right_edge(dstinfo);
-    break;
-  case JXFORM_ROT_180:
-    if (info->trim) {
-      trim_right_edge(dstinfo);
-      trim_bottom_edge(dstinfo);
-    }
-    break;
   case JXFORM_ROT_270:
     transpose_critical_parameters(dstinfo);
-    if (info->trim)
-      trim_bottom_edge(dstinfo);
     break;
   }
 
+  /* Adjust Exif properties */
+  if (srcinfo->marker_list != NULL &&
+      srcinfo->marker_list->marker == JPEG_APP0+1 &&
+      srcinfo->marker_list->data_length >= 6 &&
+      GETJOCTET(srcinfo->marker_list->data[0]) == 0x45 &&
+      GETJOCTET(srcinfo->marker_list->data[1]) == 0x78 &&
+      GETJOCTET(srcinfo->marker_list->data[2]) == 0x69 &&
+      GETJOCTET(srcinfo->marker_list->data[3]) == 0x66 &&
+      GETJOCTET(srcinfo->marker_list->data[4]) == 0 &&
+      GETJOCTET(srcinfo->marker_list->data[5]) == 0) {
+    /* Suppress output of JFIF marker */
+    dstinfo->write_JFIF_header = FALSE;
+    /* Adjust Exif image parameters */
+    if (dstinfo->image_width != srcinfo->image_width ||
+	dstinfo->image_height != srcinfo->image_height)
+      /* Align data segment to start of TIFF structure for parsing */
+      adjust_exif_parameters(srcinfo->marker_list->data + 6,
+	srcinfo->marker_list->data_length - 6,
+	dstinfo->image_width, dstinfo->image_height);
+  }
+
   /* Return the appropriate output data set */
   if (info->workspace_coef_arrays != NULL)
     return info->workspace_coef_arrays;
@@ -816,40 +1349,108 @@
  */
 
 GLOBAL(void)
-jtransform_execute_transformation (j_decompress_ptr srcinfo,
-				   j_compress_ptr dstinfo,
-				   jvirt_barray_ptr *src_coef_arrays,
-				   jpeg_transform_info *info)
+jtransform_execute_transform (j_decompress_ptr srcinfo,
+			      j_compress_ptr dstinfo,
+			      jvirt_barray_ptr *src_coef_arrays,
+			      jpeg_transform_info *info)
 {
   jvirt_barray_ptr *dst_coef_arrays = info->workspace_coef_arrays;
 
+  /* Note: conditions tested here should match those in switch statement
+   * in jtransform_request_workspace()
+   */
   switch (info->transform) {
   case JXFORM_NONE:
+    if (info->x_crop_offset != 0 || info->y_crop_offset != 0)
+      do_crop(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	      src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_FLIP_H:
-    do_flip_h(srcinfo, dstinfo, src_coef_arrays);
+    if (info->y_crop_offset != 0)
+      do_flip_h(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+		src_coef_arrays, dst_coef_arrays);
+    else
+      do_flip_h_no_crop(srcinfo, dstinfo, info->x_crop_offset,
+			src_coef_arrays);
     break;
   case JXFORM_FLIP_V:
-    do_flip_v(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_flip_v(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	      src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_TRANSPOSE:
-    do_transpose(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_transpose(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+		 src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_TRANSVERSE:
-    do_transverse(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_transverse(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+		  src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_ROT_90:
-    do_rot_90(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_rot_90(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	      src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_ROT_180:
-    do_rot_180(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_rot_180(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	       src_coef_arrays, dst_coef_arrays);
     break;
   case JXFORM_ROT_270:
-    do_rot_270(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    do_rot_270(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	       src_coef_arrays, dst_coef_arrays);
     break;
   }
 }
 
+/* jtransform_perfect_transform
+ *
+ * Determine whether lossless transformation is perfectly
+ * possible for a specified image and transformation.
+ *
+ * Inputs:
+ *   image_width, image_height: source image dimensions.
+ *   MCU_width, MCU_height: pixel dimensions of MCU.
+ *   transform: transformation identifier.
+ * Parameter sources from initialized jpeg_struct
+ * (after reading source header):
+ *   image_width = cinfo.image_width
+ *   image_height = cinfo.image_height
+ *   MCU_width = cinfo.max_h_samp_factor * DCTSIZE
+ *   MCU_height = cinfo.max_v_samp_factor * DCTSIZE
+ * Result:
+ *   TRUE = perfect transformation possible
+ *   FALSE = perfect transformation not possible
+ *           (may use custom action then)
+ */
+
+GLOBAL(boolean)
+jtransform_perfect_transform(JDIMENSION image_width, JDIMENSION image_height,
+			     int MCU_width, int MCU_height,
+			     JXFORM_CODE transform)
+{
+  boolean result = TRUE; /* initialize TRUE */
+
+  switch (transform) {
+  case JXFORM_FLIP_H:
+  case JXFORM_ROT_270:
+    if (image_width % (JDIMENSION) MCU_width)
+      result = FALSE;
+    break;
+  case JXFORM_FLIP_V:
+  case JXFORM_ROT_90:
+    if (image_height % (JDIMENSION) MCU_height)
+      result = FALSE;
+    break;
+  case JXFORM_TRANSVERSE:
+  case JXFORM_ROT_180:
+    if (image_width % (JDIMENSION) MCU_width)
+      result = FALSE;
+    if (image_height % (JDIMENSION) MCU_height)
+      result = FALSE;
+    break;
+  }
+
+  return result;
+}
+
 #endif /* TRANSFORMS_SUPPORTED */
 
 
--- libjpeg6b-6b.orig/jpeglib.h
+++ libjpeg6b-6b/jpeglib.h
@@ -13,6 +13,10 @@
 #ifndef JPEGLIB_H
 #define JPEGLIB_H
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /*
  * First we include the configuration files that record how this
  * installation of the JPEG library is set up.  jconfig.h can be
@@ -1093,4 +1097,8 @@
 #include "jerror.h"		/* fetch error codes too */
 #endif
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* JPEGLIB_H */
--- libjpeg6b-6b.orig/config.sub
+++ libjpeg6b-6b/config.sub
@@ -1,4 +1,10 @@
 #! /bin/sh
+# autotools-dev hack (<ballombe@debian.org>, Wed, 14 Nov 2001 10:13:10 +0100)
+if [ -x /usr/share/misc/config.sub ]; then
+   /usr/share/misc/config.sub $*
+   exit $?
+fi
+
 # Configuration validation subroutine script, version 1.1.
 #   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
 # This file is (in principle) common to ALL GNU software.
--- libjpeg6b-6b.orig/rdjpgcom.c
+++ libjpeg6b-6b/rdjpgcom.c
@@ -14,6 +14,7 @@
 #define JPEG_CJPEG_DJPEG	/* to get the command-line config symbols */
 #include "jinclude.h"		/* get auto-config symbols, <stdio.h> */
 
+#include <locale.h>             /*ballombe@debian.org: use locale for isprint*/
 #include <ctype.h>		/* to declare isupper(), tolower() */
 #ifdef USE_SETMODE
 #include <fcntl.h>		/* to declare setmode()'s parameter macros */
@@ -223,7 +224,10 @@
   unsigned int length;
   int ch;
   int lastch = 0;
-
+/* ballombe@debian.org Thu, 15 Nov 2001 20:04:47 +0100*/
+/* Set locale properly for isprint*/
+  setlocale(LC_CTYPE,"");
+    
   /* Get the marker parameter length count */
   length = read_2_bytes();
   /* Length includes itself, so must be at least 2 */
@@ -254,6 +258,8 @@
     length--;
   }
   printf("\n");
+/*ballombe@debian.org: revert to C locale*/
+  setlocale(LC_CTYPE,"C");
 }
 
 
--- libjpeg6b-6b.orig/rdppm.c
+++ libjpeg6b-6b/rdppm.c
@@ -250,8 +250,8 @@
   bufferptr = source->iobuffer;
   for (col = cinfo->image_width; col > 0; col--) {
     register int temp;
-    temp  = UCH(*bufferptr++);
-    temp |= UCH(*bufferptr++) << 8;
+    temp  = UCH(*bufferptr++) << 8;
+    temp |= UCH(*bufferptr++);
     *ptr++ = rescale[temp];
   }
   return 1;
@@ -274,14 +274,14 @@
   bufferptr = source->iobuffer;
   for (col = cinfo->image_width; col > 0; col--) {
     register int temp;
-    temp  = UCH(*bufferptr++);
-    temp |= UCH(*bufferptr++) << 8;
+    temp  = UCH(*bufferptr++) << 8;
+    temp |= UCH(*bufferptr++);
     *ptr++ = rescale[temp];
-    temp  = UCH(*bufferptr++);
-    temp |= UCH(*bufferptr++) << 8;
+    temp  = UCH(*bufferptr++) << 8;
+    temp |= UCH(*bufferptr++);
     *ptr++ = rescale[temp];
-    temp  = UCH(*bufferptr++);
-    temp |= UCH(*bufferptr++) << 8;
+    temp  = UCH(*bufferptr++) << 8;
+    temp |= UCH(*bufferptr++);
     *ptr++ = rescale[temp];
   }
   return 1;
--- libjpeg6b-6b.orig/jpegtran.c
+++ libjpeg6b-6b/jpegtran.c
@@ -1,7 +1,7 @@
 /*
  * jpegtran.c
  *
- * Copyright (C) 1995-1997, Thomas G. Lane.
+ * Copyright (C) 1995-2001, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -64,8 +64,10 @@
 #endif
 #if TRANSFORMS_SUPPORTED
   fprintf(stderr, "Switches for modifying the image:\n");
+  fprintf(stderr, "  -crop WxH+X+Y  Crop to a rectangular subarea\n");
   fprintf(stderr, "  -grayscale     Reduce to grayscale (omit color data)\n");
   fprintf(stderr, "  -flip [horizontal|vertical]  Mirror image (left-right or top-bottom)\n");
+  fprintf(stderr, "  -perfect       Fail if there is non-transformable edge blocks\n");
   fprintf(stderr, "  -rotate [90|180|270]         Rotate image (degrees clockwise)\n");
   fprintf(stderr, "  -transpose     Transpose image\n");
   fprintf(stderr, "  -transverse    Transverse transpose image\n");
@@ -133,7 +135,9 @@
   copyoption = JCOPYOPT_DEFAULT;
   transformoption.transform = JXFORM_NONE;
   transformoption.trim = FALSE;
+  transformoption.perfect = FALSE;
   transformoption.force_grayscale = FALSE;
+  transformoption.crop = FALSE;
   cinfo->err->trace_level = 0;
 
   /* Scan command line options, adjust parameters */
@@ -160,7 +164,7 @@
       exit(EXIT_FAILURE);
 #endif
 
-    } else if (keymatch(arg, "copy", 1)) {
+    } else if (keymatch(arg, "copy", 2)) {
       /* Select which extra markers to copy. */
       if (++argn >= argc)	/* advance to next argument */
 	usage();
@@ -173,6 +177,20 @@
       } else
 	usage();
 
+    } else if (keymatch(arg, "crop", 2)) {
+      /* Perform lossless cropping. */
+#if TRANSFORMS_SUPPORTED
+      if (++argn >= argc)	/* advance to next argument */
+	usage();
+      if (! jtransform_parse_crop_spec(&transformoption, argv[argn])) {
+	fprintf(stderr, "%s: bogus -crop argument '%s'\n",
+		progname, argv[argn]);
+	exit(EXIT_FAILURE);
+      }
+#else
+      select_transform(JXFORM_NONE);	/* force an error */
+#endif
+
     } else if (keymatch(arg, "debug", 1) || keymatch(arg, "verbose", 1)) {
       /* Enable debug printouts. */
       /* On first -d, print version identification */
@@ -233,7 +251,12 @@
 	usage();
       outfilename = argv[argn];	/* save it away for later use */
 
-    } else if (keymatch(arg, "progressive", 1)) {
+    } else if (keymatch(arg, "perfect", 2)) {
+      /* Fail if there is any partial edge MCUs that the transform can't
+       * handle. */
+      transformoption.perfect = TRUE;
+
+    } else if (keymatch(arg, "progressive", 2)) {
       /* Select simple progressive mode. */
 #ifdef C_PROGRESSIVE_SUPPORTED
       simple_progressive = TRUE;
@@ -342,8 +365,10 @@
   jvirt_barray_ptr * src_coef_arrays;
   jvirt_barray_ptr * dst_coef_arrays;
   int file_index;
-  FILE * input_file;
-  FILE * output_file;
+  /* We assume all-in-memory processing and can therefore use only a
+   * single file pointer for sequential input and output operation. 
+   */
+  FILE * fp;
 
   /* On Mac, fetch a command line. */
 #ifdef USE_CCOMMAND
@@ -406,24 +431,13 @@
 
   /* Open the input file. */
   if (file_index < argc) {
-    if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {
-      fprintf(stderr, "%s: can't open %s\n", progname, argv[file_index]);
+    if ((fp = fopen(argv[file_index], READ_BINARY)) == NULL) {
+      fprintf(stderr, "%s: can't open %s for reading\n", progname, argv[file_index]);
       exit(EXIT_FAILURE);
     }
   } else {
     /* default input file is stdin */
-    input_file = read_stdin();
-  }
-
-  /* Open the output file. */
-  if (outfilename != NULL) {
-    if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {
-      fprintf(stderr, "%s: can't open %s\n", progname, outfilename);
-      exit(EXIT_FAILURE);
-    }
-  } else {
-    /* default output file is stdout */
-    output_file = write_stdout();
+    fp = read_stdin();
   }
 
 #ifdef PROGRESS_REPORT
@@ -431,7 +445,7 @@
 #endif
 
   /* Specify data source for decompression */
-  jpeg_stdio_src(&srcinfo, input_file);
+  jpeg_stdio_src(&srcinfo, fp);
 
   /* Enable saving of extra markers that we want to copy */
   jcopy_markers_setup(&srcinfo, copyoption);
@@ -443,6 +457,15 @@
    * jpeg_read_coefficients so that memory allocation will be done right.
    */
 #if TRANSFORMS_SUPPORTED
+  /* Fails right away if -perfect is given and transformation is not perfect.
+   */
+  if (transformoption.perfect &&
+      !jtransform_perfect_transform(srcinfo.image_width, srcinfo.image_height,
+      srcinfo.max_h_samp_factor * DCTSIZE, srcinfo.max_v_samp_factor * DCTSIZE,
+      transformoption.transform)) {
+    fprintf(stderr, "%s: transformation is not perfect\n", progname);
+    exit(EXIT_FAILURE);
+  }
   jtransform_request_workspace(&srcinfo, &transformoption);
 #endif
 
@@ -463,11 +486,32 @@
   dst_coef_arrays = src_coef_arrays;
 #endif
 
+  /* Close input file, if we opened it.
+   * Note: we assume that jpeg_read_coefficients consumed all input
+   * until JPEG_REACHED_EOI, and that jpeg_finish_decompress will
+   * only consume more while (! cinfo->inputctl->eoi_reached).
+   * We cannot call jpeg_finish_decompress here since we still need the
+   * virtual arrays allocated from the source object for processing.
+   */
+  if (fp != stdin)
+    fclose(fp);
+
+  /* Open the output file. */
+  if (outfilename != NULL) {
+    if ((fp = fopen(outfilename, WRITE_BINARY)) == NULL) {
+      fprintf(stderr, "%s: can't open %s for writing\n", progname, outfilename);
+      exit(EXIT_FAILURE);
+    }
+  } else {
+    /* default output file is stdout */
+    fp = write_stdout();
+  }
+
   /* Adjust default compression parameters by re-parsing the options */
   file_index = parse_switches(&dstinfo, argc, argv, 0, TRUE);
 
   /* Specify data destination for compression */
-  jpeg_stdio_dest(&dstinfo, output_file);
+  jpeg_stdio_dest(&dstinfo, fp);
 
   /* Start compressor (note no image data is actually written here) */
   jpeg_write_coefficients(&dstinfo, dst_coef_arrays);
@@ -488,11 +532,9 @@
   (void) jpeg_finish_decompress(&srcinfo);
   jpeg_destroy_decompress(&srcinfo);
 
-  /* Close files, if we opened them */
-  if (input_file != stdin)
-    fclose(input_file);
-  if (output_file != stdout)
-    fclose(output_file);
+  /* Close output file, if we opened it */
+  if (fp != stdout)
+    fclose(fp);
 
 #ifdef PROGRESS_REPORT
   end_progress_monitor((j_common_ptr) &dstinfo);
--- libjpeg6b-6b.orig/config.guess
+++ libjpeg6b-6b/config.guess
@@ -1,4 +1,10 @@
 #! /bin/sh
+# autotools-dev hack (<ballombe@debian.org>, Wed, 14 Nov 2001 10:13:10 +0100)
+if [ -x /usr/share/misc/config.guess ]; then
+   /usr/share/misc/config.guess $*
+   exit $?
+fi
+
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
 #
--- libjpeg6b-6b.orig/jerror.h
+++ libjpeg6b-6b/jerror.h
@@ -45,6 +45,7 @@
 JMESSAGE(JERR_BAD_ALLOC_CHUNK, "MAX_ALLOC_CHUNK is wrong, please fix")
 JMESSAGE(JERR_BAD_BUFFER_MODE, "Bogus buffer control mode")
 JMESSAGE(JERR_BAD_COMPONENT_ID, "Invalid component ID %d in SOS")
+JMESSAGE(JERR_BAD_CROP_SPEC, "Invalid crop request")
 JMESSAGE(JERR_BAD_DCT_COEF, "DCT coefficient out of range")
 JMESSAGE(JERR_BAD_DCTSIZE, "IDCT output block size %d not supported")
 JMESSAGE(JERR_BAD_HUFF_TABLE, "Bogus Huffman table definition")
--- libjpeg6b-6b.orig/debian/patch.mk
+++ libjpeg6b-6b/debian/patch.mk
@@ -0,0 +1,63 @@
+# -*- Makefile -*-, you silly Emacs!
+#From the dpatch debian package.
+#Copyright (C) 2002, 2003  Gergely Nagy, Joerg Jaspert
+#Released under the GPL
+
+DPATCH_ARCH	 = $(shell dpkg-architecture -qDEB_BUILD_ARCH)
+PATCHLIST_ALL	 = $(shell cat debian/patches/00list | grep -v ^\# )
+PATCHLIST_ARCH	 = $(shell cat debian/patches/00list.${DPATCH_ARCH} | grep -v ^\# 2>/dev/null)
+PATCHLIST	?= $(sort ${PATCHLIST_ALL} ${PATCHLIST_ARCH})
+
+UNPATCHLIST	 = $(shell echo ${PATCHLIST} | tr ' ' '\n' | tac)
+
+patch: patch-stamp
+patch-stamp:
+	test -d debian/patched || install -d debian/patched
+	@echo "Patches applied in the Debian version of ${PACKAGE}:" > $@T
+	@for patch in ${PATCHLIST}; do \
+		patchdir=$${patch%/*}; \
+		test "x$$patchdir" = "x$$patch" || \
+			install -d debian/patched/$$patchdir; \
+                stamp=debian/patched/$${patch%%.dpatch}.dpatch; \
+		test -e debian/patches/$$patch || ext=.dpatch; \
+                patch=debian/patches/$$patch$$ext; \
+                author=`sed -n "s,^#* *.*dpatch by *,,p" $$patch`; \
+                test -x $$patch || chmod +x $$patch; \
+		if test -f $$stamp; then \
+                        echo "$$patch already applied."; \
+                        echo -e "\n$$patch ($$author):" >> $@T; \
+                        sed -n 's/^#* *DP: */  /p' $$patch >> $@T; \
+                else \
+                        echo -n "applying patch $$patch..."; \
+                        if $$patch -patch >$$stamp.new 2>&1; then \
+                                mv $$stamp.new $$stamp; \
+                                touch $$stamp; \
+                                echo -e "\n$$patch ($$author):" >> $@T; \
+                                sed -n 's/^#* *DP: */  /p' $$patch >> $@T; \
+                                echo " ok."; \
+                        else \
+                                echo " failed."; \
+                                exit 1; \
+                        fi; \
+                fi; \
+	done
+	mv -f $@T $@
+
+unpatch:
+	@for patch in ${UNPATCHLIST}; do \
+                stamp=debian/patched/$${patch%%.dpatch}.dpatch; \
+		test -e debian/patches/$$patch || ext=.dpatch; \
+                patch=debian/patches/$$patch$$ext; \
+                test -x $$patch || chmod +x $$patch; \
+                if test -f $$stamp; then \
+                        echo -n "reverting patch $$patch..."; \
+                        if $$patch -unpatch 2>&1 >/dev/null; then \
+                                rm -f $$stamp; \
+                                echo " ok."; \
+                        else \
+                                echo " failed."; \
+                                exit 1; \
+                        fi; \
+                fi; \
+	done
+	rm -rf patch-stamp patch-stampT debian/patched
--- libjpeg6b-6b.orig/debian/libjpeg-progs.README.Debian
+++ libjpeg6b-6b/debian/libjpeg-progs.README.Debian
@@ -0,0 +1,27 @@
+This is the libjpeg-progs Debian package.
+This package contains programs for manipulating JPEG files:
+   cjpeg/djpeg: convert to/from the JPEG file format
+   rdjpgcom/wrjpgcom: read/write comments in JPEG files
+   jpegtran: lossless transformations of JPEG files
+   jpegexiforient/exifautotran: manipulate EXIF orientation tag
+       
+The following patches has been applied:
+
+-- Combined EXIF/Lossless-crop/-perfect patch from 
+<http://sylvana.net/jpegcrop/croppatch.tar.gz> by <guido@jpegclub.org>.
+
+-- Patch for rdjpgcom to honor locale setting.
+
+-- Patch for jpegtran to implement the -perfect option.
+
+-- Patch for cjpeg to fix a byte order issue with 16bit PPM/PGM files.
+
+The following configuration option has been set:
+
+--enable-maxmem=1024: This limits the use of RAM to 1Gb before using 
+   temporary files. More importantly this allows to use the JPEGMEM
+   environment variable to limit RAM usage in favour of temporary files.
+   See jpegtran(1).
+
+--
+Bill Allombert <ballombe@debian.org>  Fri,  5 May 2006 18:59:41 +0200
--- libjpeg6b-6b.orig/debian/shlibs.local
+++ libjpeg6b-6b/debian/shlibs.local
@@ -0,0 +1 @@
+libjpeg		62	libjpeg62
--- libjpeg6b-6b.orig/debian/extra/jpegexiforient.c
+++ libjpeg6b-6b/debian/extra/jpegexiforient.c
@@ -0,0 +1,299 @@
+/*
+ * jpegexiforient.c
+ *
+ * This is a utility program to get and set the Exif Orientation Tag.
+ * It can be used together with jpegtran in scripts for automatic
+ * orientation correction of digital camera pictures.
+ *
+ * The Exif orientation value gives the orientation of the camera
+ * relative to the scene when the image was captured.  The relation
+ * of the '0th row' and '0th column' to visual position is shown as
+ * below.
+ *
+ * Value | 0th Row     | 0th Column
+ * ------+-------------+-----------
+ *   1   | top         | left side
+ *   2   | top         | rigth side
+ *   3   | bottom      | rigth side
+ *   4   | bottom      | left side
+ *   5   | left side   | top
+ *   6   | right side  | top
+ *   7   | right side  | bottom
+ *   8   | left side   | bottom
+ *
+ * For convenience, here is what the letter F would look like if it were
+ * tagged correctly and displayed by a program that ignores the orientation
+ * tag:
+ *
+ *   1        2       3      4         5            6           7          8
+ *
+ * 888888  888888      88  88      8888888888  88                  88  8888888888
+ * 88          88      88  88      88  88      88  88          88  88      88  88
+ * 8888      8888    8888  8888    88          8888888888  8888888888          88
+ * 88          88      88  88
+ * 88          88  888888  888888
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+static FILE * myfile;		/* My JPEG file */
+
+static unsigned char exif_data[65536L];
+
+/* Return next input byte, or EOF if no more */
+#define NEXTBYTE()  getc(myfile)
+
+/* Error exit handler */
+#define ERREXIT(msg)  (exit(0))
+
+/* Read one byte, testing for EOF */
+static int
+read_1_byte (void)
+{
+  int c;
+
+  c = NEXTBYTE();
+  if (c == EOF)
+    ERREXIT("Premature EOF in JPEG file");
+  return c;
+}
+
+/* Read 2 bytes, convert to unsigned int */
+/* All 2-byte quantities in JPEG markers are MSB first */
+static unsigned int
+read_2_bytes (void)
+{
+  int c1, c2;
+
+  c1 = NEXTBYTE();
+  if (c1 == EOF)
+    ERREXIT("Premature EOF in JPEG file");
+  c2 = NEXTBYTE();
+  if (c2 == EOF)
+    ERREXIT("Premature EOF in JPEG file");
+  return (((unsigned int) c1) << 8) + ((unsigned int) c2);
+}
+
+static const char * progname;	/* program name for error messages */
+
+static void
+usage (FILE *out)
+/* complain about bad command line */
+{
+  fprintf(out, "jpegexiforient reads or writes the Exif Orientation Tag ");
+  fprintf(out, "in a JPEG Exif file.\n");
+
+  fprintf(out, "Usage: %s [switches] jpegfile\n", progname);
+
+  fprintf(out, "Switches:\n");
+  fprintf(out, "  --help     display this help and exit\n");
+  fprintf(out, "  --version  output version information and exit\n");
+  fprintf(out, "  -n         Do not output the trailing newline\n");
+  fprintf(out, "  -1 .. -8   Set orientation value 1 .. 8\n");
+}
+
+/*
+ * The main program.
+ */
+
+int
+main (int argc, char **argv)
+{
+  int n_flag, set_flag;
+  unsigned int length, i;
+  int is_motorola; /* Flag for byte order */
+  unsigned int offset, number_of_tags, tagnum;
+
+  progname = argv[0];
+  if (progname == NULL || progname[0] == 0)
+    progname = "jpegexiforient";	/* in case C library doesn't provide it */
+
+  if (argc < 2) { usage(stderr); return 1; }
+
+  n_flag = 0; set_flag = 0;
+
+  i = 1;
+  while (argv[i][0] == '-') {
+    switch (argv[i][1]) {
+    case '-': 
+      switch (argv[i][2]) {
+        case 'h': usage(stdout); return 0;
+        case 'v': fprintf(stdout,"jpegexiforient\n"); return 0;
+        }
+    case 'n':
+      n_flag = 1;
+      break;
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+    case '5':
+    case '6':
+    case '7':
+    case '8':
+      set_flag = argv[i][1] - '0';
+      break;
+    default:
+      usage(stderr); return 1;
+    }
+    if (++i >= argc) { usage(stderr); return 1; }
+  }
+
+  if (set_flag) {
+    if ((myfile = fopen(argv[i], "rb+")) == NULL) {
+      fprintf(stderr, "%s: can't open %s\n", progname, argv[i]);
+      return 0;
+    }
+  } else {
+    if ((myfile = fopen(argv[i], "rb")) == NULL) {
+      fprintf(stderr, "%s: can't open %s\n", progname, argv[i]);
+      return 0;
+    }
+  }
+
+  /* Read File head, check for JPEG SOI + Exif APP1 */
+  for (i = 0; i < 4; i++)
+    exif_data[i] = (unsigned char) read_1_byte();
+  if (exif_data[0] != 0xFF ||
+      exif_data[1] != 0xD8 ||
+      exif_data[2] != 0xFF ||
+      exif_data[3] != 0xE1)
+    return 0;
+
+  /* Get the marker parameter length count */
+  length = read_2_bytes();
+  /* Length includes itself, so must be at least 2 */
+  /* Following Exif data length must be at least 6 */
+  if (length < 8)
+    return 0;
+  length -= 8;
+  /* Read Exif head, check for "Exif" */
+  for (i = 0; i < 6; i++)
+    exif_data[i] = (unsigned char) read_1_byte();
+  if (exif_data[0] != 0x45 ||
+      exif_data[1] != 0x78 ||
+      exif_data[2] != 0x69 ||
+      exif_data[3] != 0x66 ||
+      exif_data[4] != 0 ||
+      exif_data[5] != 0)
+    return 0;
+  /* Read Exif body */
+  for (i = 0; i < length; i++)
+    exif_data[i] = (unsigned char) read_1_byte();
+
+  if (length < 12) return 0; /* Length of an IFD entry */
+
+  /* Discover byte order */
+  if (exif_data[0] == 0x49 && exif_data[1] == 0x49)
+    is_motorola = 0;
+  else if (exif_data[0] == 0x4D && exif_data[1] == 0x4D)
+    is_motorola = 1;
+  else
+    return 0;
+
+  /* Check Tag Mark */
+  if (is_motorola) {
+    if (exif_data[2] != 0) return 0;
+    if (exif_data[3] != 0x2A) return 0;
+  } else {
+    if (exif_data[3] != 0) return 0;
+    if (exif_data[2] != 0x2A) return 0;
+  }
+
+  /* Get first IFD offset (offset to IFD0) */
+  if (is_motorola) {
+    if (exif_data[4] != 0) return 0;
+    if (exif_data[5] != 0) return 0;
+    offset = exif_data[6];
+    offset <<= 8;
+    offset += exif_data[7];
+  } else {
+    if (exif_data[7] != 0) return 0;
+    if (exif_data[6] != 0) return 0;
+    offset = exif_data[5];
+    offset <<= 8;
+    offset += exif_data[4];
+  }
+  if (offset > length - 2) return 0; /* check end of data segment */
+
+  /* Get the number of directory entries contained in this IFD */
+  if (is_motorola) {
+    number_of_tags = exif_data[offset];
+    number_of_tags <<= 8;
+    number_of_tags += exif_data[offset+1];
+  } else {
+    number_of_tags = exif_data[offset+1];
+    number_of_tags <<= 8;
+    number_of_tags += exif_data[offset];
+  }
+  if (number_of_tags == 0) return 0;
+  offset += 2;
+
+  /* Search for Orientation Tag in IFD0 */
+  for (;;) {
+    if (offset > length - 12) return 0; /* check end of data segment */
+    /* Get Tag number */
+    if (is_motorola) {
+      tagnum = exif_data[offset];
+      tagnum <<= 8;
+      tagnum += exif_data[offset+1];
+    } else {
+      tagnum = exif_data[offset+1];
+      tagnum <<= 8;
+      tagnum += exif_data[offset];
+    }
+    if (tagnum == 0x0112) break; /* found Orientation Tag */
+    if (--number_of_tags == 0) return 0;
+    offset += 12;
+  }
+
+  if (set_flag) {
+    /* Set the Orientation value */
+    if (is_motorola) {
+      exif_data[offset+2] = 0; /* Format = unsigned short (2 octets) */
+      exif_data[offset+3] = 3;
+      exif_data[offset+4] = 0; /* Number Of Components = 1 */
+      exif_data[offset+5] = 0;
+      exif_data[offset+6] = 0;
+      exif_data[offset+7] = 1;
+      exif_data[offset+8] = 0;
+      exif_data[offset+9] = (unsigned char)set_flag;
+      exif_data[offset+10] = 0;
+      exif_data[offset+11] = 0;
+    } else {
+      exif_data[offset+2] = 3; /* Format = unsigned short (2 octets) */
+      exif_data[offset+3] = 0;
+      exif_data[offset+4] = 1; /* Number Of Components = 1 */
+      exif_data[offset+5] = 0;
+      exif_data[offset+6] = 0;
+      exif_data[offset+7] = 0;
+      exif_data[offset+8] = (unsigned char)set_flag;
+      exif_data[offset+9] = 0;
+      exif_data[offset+10] = 0;
+      exif_data[offset+11] = 0;
+    }
+    fseek(myfile, (4 + 2 + 6 + 2) + offset, SEEK_SET);
+    fwrite(exif_data + 2 + offset, 1, 10, myfile);
+  } else {
+    /* Get the Orientation value */
+    if (is_motorola) {
+      if (exif_data[offset+8] != 0) return 0;
+      set_flag = exif_data[offset+9];
+    } else {
+      if (exif_data[offset+9] != 0) return 0;
+      set_flag = exif_data[offset+8];
+    }
+    if (set_flag > 8) return 0;
+  }
+
+  /* Write out Orientation value */
+  if (n_flag)
+    printf("%c", '0' + set_flag);
+  else
+    printf("%c\n", '0' + set_flag);
+
+  /* All done. */
+  return 0;
+}
--- libjpeg6b-6b.orig/debian/extra/exifautotran.1
+++ libjpeg6b-6b/debian/extra/exifautotran.1
@@ -0,0 +1,13 @@
+.TH EXIFAUTOTRAN "1" "February 2005" "exifautotran" "User Commands"
+.SH NAME
+exifautotran \- Transforms Exif files so that Orientation becomes 1
+.SH DESCRIPTION
+exifautotran [list of files]
+.PP
+Take a list of files as input and transform them in place so that the
+Orientation becomes 1.
+.SH "AUTHOR"
+    Guido Vollbeding <guido@jpegclub.org>
+.SH "SEE ALSO"
+.BR jpegtran(1)
+.BR jpegexiforient(1)
--- libjpeg6b-6b.orig/debian/extra/jpegexiforient.1
+++ libjpeg6b-6b/debian/extra/jpegexiforient.1
@@ -0,0 +1,73 @@
+.TH JPEGEXIFORIENT "1" "February 2005" "jpegexiforient" "User Commands"
+.SH NAME
+jpegexiforient \- reads or writes the Exif Orientation Tag
+.SH SYNOPSIS
+.B jpegexiforient
+[\fIswitches\fR] \fIjpegfile\fR
+.SH DESCRIPTION
+.
+This is a utility program to get and set the Exif Orientation Tag.
+It can be used together with jpegtran in scripts for automatic
+orientation correction of digital camera pictures.
+.PP
+The Exif orientation value gives the orientation of the camera
+relative to the scene when the image was captured.  The relation
+of the '0th row' and '0th column' to visual position is shown as
+below.
+.IP
+.nf
+.ft CR
+Value | 0th Row     | 0th Column
+------+-------------+-----------
+  1   | top         | left side
+  2   | top         | rigth side
+  3   | bottom      | rigth side
+  4   | bottom      | left side
+  5   | left side   | top
+  6   | right side  | top
+  7   | right side  | bottom
+  8   | left side   | bottom
+.fi
+.PP
+For convenience, here is what the letter F would look like if it were
+tagged correctly and displayed by a program that ignores the orientation
+tag:
+.IP
+.nf
+.ft CB
+  1        2       3      4     
+
+888888  888888      88  88      
+88          88      88  88      
+8888      8888    8888  8888    
+88          88      88  88
+88          88  888888  888888
+
+    5            6           7          8
+                                               
+8888888888  88                  88  8888888888
+88  88      88  88          88  88      88  88
+88          8888888888  8888888888          88
+.fi
+.PP
+jpegexiforient output the Exif Orientation Tag in a JPEG Exif file.
+With the options -1 .. -8, it can also be used to set the tag.
+.
+.SS "OPTIONS"
+.TP
+\fB\-\-help\fR
+display this help and exit
+.TP
+\fB\-\-version\fR
+output version information and exit
+.TP
+\fB\-n\fR
+Do not output the trailing newline
+.TP
+\fB\-1\fR .. \fB\-8\fR
+Set orientation value 1 .. 8
+.SH "AUTHOR"
+ Guido Vollbeding <guido@jpegclub.org>
+.SH "SEE ALSO"
+.BR jpegtran(1)
+.BR exifautotran(1)
--- libjpeg6b-6b.orig/debian/extra/exifautotran
+++ libjpeg6b-6b/debian/extra/exifautotran
@@ -0,0 +1,50 @@
+#!/bin/sh
+# exifautotran [list of files]
+#
+# Transforms Exif files so that Orientation becomes 1
+#
+
+trap "if test -n \"\$tempfile\"; then rm -f \"\$tempfile\"; fi" INT QUIT TERM
+
+for i
+do
+ case $i in
+ -v|--version) echo "exifautotran"; exit 0;;
+ -h|--help) 
+             cat <<EOF
+exifautotran [list of files]
+
+Transforms Exif files so that Orientation becomes 1
+EOF
+             exit 0;;
+ esac
+
+ case `jpegexiforient -n "$i"` in
+ 1) transform="";;
+ 2) transform="-flip horizontal";;
+ 3) transform="-rotate 180";;
+ 4) transform="-flip vertical";;
+ 5) transform="-transpose";;
+ 6) transform="-rotate 90";;
+ 7) transform="-transverse";;
+ 8) transform="-rotate 270";;
+ *) transform="";;
+ esac
+ if test -n "$transform"; then
+  tempfile=`mktemp`;
+  if test "$?" -ne "0"; then
+    echo "Failed to create temporary file" >&2
+    exit 1;
+  fi
+  echo Executing: jpegtran -copy all $transform $i >&2
+  jpegtran -copy all $transform "$i" > $tempfile
+  if test $? -ne 0; then
+   echo Error while transforming $i - skipped. >&2
+   rm "$tempfile"
+  else
+   cp "$tempfile" "$i"
+   rm "$tempfile"
+   jpegexiforient -1 "$i" > /dev/null
+  fi
+ fi
+done
--- libjpeg6b-6b.orig/debian/extra/Makefile
+++ libjpeg6b-6b/debian/extra/Makefile
@@ -0,0 +1,19 @@
+CFLAGS = -O2 -Wall -g
+CC = cc
+INSTALL = install -m755 -o root -g root
+DESTDIR =
+prefix  = /usr/local
+bindir  = $(prefix)/bin
+mandir  = $(prefix)/share/man/man1
+
+all: jpegexiforient
+
+jpegexiforient: jpegexiforient.c
+	$(CC) $(CFLAGS) -o jpegexiforient jpegexiforient.c
+clean:
+	-rm -f jpegexiforient
+install:
+	$(INSTALL) jpegexiforient    $(DESTDIR)$(bindir)
+	$(INSTALL) jpegexiforient.1  $(DESTDIR)$(mandir)
+	$(INSTALL) exifautotran      $(DESTDIR)$(bindir)
+	$(INSTALL) exifautotran.1    $(DESTDIR)$(mandir)
--- libjpeg6b-6b.orig/debian/rules
+++ libjpeg6b-6b/debian/rules
@@ -0,0 +1,84 @@
+#!/usr/bin/make -f
+# Made with the aid of debmake, by Christoph Lameter,
+# based on the sample debian/rules file for GNU hello by Ian Jackson.
+
+package=libjpeg
+
+export DEB_HOST_GNU_TYPE  ?= $(shell dpkg-architecture -qDEB_HOST_GNU_TYPE)
+export DEB_BUILD_GNU_TYPE ?= $(shell dpkg-architecture -qDEB_BUILD_GNU_TYPE)
+
+include debian/patch.mk
+
+export CFLAGS=-D_REENTRANT -g -Wall
+ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
+CFLAGS += -O0
+else
+CFLAGS += -O2
+endif
+
+#export DH_VERBOSE=1
+
+build: build-stamp 
+build-stamp: patch-stamp
+	dh_testdir
+	./configure --prefix=/usr --mandir=usr/share/man \
+	 --enable-static --enable-shared --enable-maxmem=1024 \
+	 --build=$(DEB_BUILD_GNU_TYPE) --host=$(DEB_HOST_GNU_TYPE) 
+	printf '#!/bin/sh\nexec libtool "$$@"\n' >libtool
+	$(MAKE)
+	$(MAKE) test
+	$(MAKE) -C debian/extra
+
+	touch build-stamp
+
+clean: patch
+	dh_testdir
+	dh_testroot
+	-rm -f build-stamp
+	if [ -f Makefile ]; then $(MAKE) clean; fi
+	$(MAKE) clean -C debian/extra
+	-rm -f libtool libtool.cfg Makefile jconfig.h config.log
+	dh_clean
+
+binary-indep: 
+
+binary-arch: build
+	dh_testdir 
+	dh_testroot 
+	dh_clean -k
+	dh_installdirs 
+	mkdir --parents debian/tmp/usr/bin \
+	                debian/tmp/usr/lib \
+			debian/tmp/usr/include \
+			debian/tmp/usr/share/man/man1
+	$(MAKE) install \
+		prefix=`pwd`/debian/tmp/usr \
+		mandir=`pwd`/debian/tmp/usr/share/man/man1
+	$(MAKE) install -C debian/extra prefix=`pwd`/debian/tmp/usr
+#<ballombe@debian.org>:mjpegtools require this file to build and header say:
+# * These declarations are considered internal to the JPEG library; most
+# * applications using the library shouldn't need to include this file.
+# So it is not forbidden to use it, therefore it must be installed.
+	install -m644 jpegint.h debian/tmp/usr/include
+	# fix jconfig.h 
+	rm debian/tmp/usr/include/jconfig.h
+	sed -e "s/#\(undef\|define\) HAVE_STD\(DEF\|LIB\)_H//g" \
+		jconfig.h > debian/tmp/usr/include/jconfig.h
+	# separate out lib package
+	dh_movefiles
+	# Finish it off with debhelper
+	dh_installdocs README
+	dh_installexamples 
+	dh_installchangelogs change.log
+	dh_strip --dbg-package=libjpeg62-dbg
+	dh_compress 
+	dh_fixperms 
+	dh_installdeb 
+	dh_shlibdeps -l`pwd`/debian/libjpeg6b/usr/lib 
+	dh_gencontrol 
+	dh_md5sums 
+	dh_builddeb 
+
+binary:	binary-indep binary-arch
+
+.PHONY: clean binary-indep binary-arch binary build patch
--- libjpeg6b-6b.orig/debian/shlibs
+++ libjpeg6b-6b/debian/shlibs
@@ -0,0 +1 @@
+libjpeg		62	libjpeg62
--- libjpeg6b-6b.orig/debian/control
+++ libjpeg6b-6b/debian/control
@@ -0,0 +1,49 @@
+Source: libjpeg6b
+Maintainer: Bill Allombert <ballombe@debian.org>
+Section: graphics
+Priority: optional
+Build-Depends: debhelper (>= 5), autotools-dev, libtool, sharutils
+Standards-Version: 3.7.2
+
+Package: libjpeg62
+Architecture: any
+Section: libs
+Description: The Independent JPEG Group's JPEG runtime library
+ The Independent JPEG Group's JPEG library is a library for handling
+ JPEG files.
+ .
+ This package contains the shared library.
+Depends: ${shlibs:Depends}
+
+Package: libjpeg62-dev
+Architecture: any
+Section: libdevel
+Description: Development files for the IJG JPEG library
+ The Independent JPEG Group's JPEG library is a library for handling
+ JPEG files.
+ .
+ This package contains the static library, headers and documentation.
+Provides: libjpeg-dev
+Depends: libjpeg62 (=${binary:Version}), libc-dev
+
+Package: libjpeg62-dbg
+Architecture: any
+Section: libdevel
+Priority: extra
+Description: Development files for the IJG JPEG library
+ The Independent JPEG Group's JPEG library is a library for handling
+ JPEG files.
+ .
+ This package contains the debugging symbols for libjpeg.
+Provides: libjpeg-dbg
+Depends: libjpeg62 (=${binary:Version})
+
+Package: libjpeg-progs
+Architecture: any
+Description: Programs for manipulating JPEG files
+ This package contains programs for manipulating JPEG files:
+  cjpeg/djpeg: convert to/from the JPEG file format
+  rdjpgcom/wrjpgcom: read/write comments in JPEG files
+  jpegtran: lossless transformations of JPEG files
+  jpegexiforient/exifautotran: manipulate EXIF orientation tag
+Depends: ${shlibs:Depends}
--- libjpeg6b-6b.orig/debian/libjpeg62-dev.README.Debian
+++ libjpeg6b-6b/debian/libjpeg62-dev.README.Debian
@@ -0,0 +1,19 @@
+The following patchs has been applied to the headers files:
+
+--- jpeglib.h: Add extern "C" {} if __cplusplus is defined.
+
+This should be harmless.
+
+--- jconfig.h: Remove unused symbol HAVE_STDDEF_H and HAVE_STDLIB_H since
+they are not used by the installed headers files and cause problem with
+autoconf.
+
+This can theoretically cause problems if your software relies on theses symbols
+being defined by this header. If it ever happens, please define them manually.
+
+Note: this is not Debian-specific, others distributions apply similar patches.
+
+Thanks for using Debian!
+
+---
+Bill Allombert <ballombe@debian.org> Mon, 20 May 2002 11:58:07 +0200
--- libjpeg6b-6b.orig/debian/postinst
+++ libjpeg6b-6b/debian/postinst
@@ -0,0 +1,8 @@
+#!/bin/sh -e
+
+#DEBHELPER#
+
+if [ "$1" = "configure" ]; then
+      ldconfig
+fi
+	
--- libjpeg6b-6b.orig/debian/README.sources
+++ libjpeg6b-6b/debian/README.sources
@@ -0,0 +1,23 @@
+libjpeg6b patch system
+----------------------
+
+libjpeg use dpatch for managing the patches applied to the upstream 
+sources. However all the patches are already applied in the .diff.gz
+so you can modify the source directly, just as before. 
+
+Extra files:
+debian/patch.mk: A local copy of /usr/share/dpatch/dpatch.make.
+
+debian/check-pristine: a shell script to check if unpatched source 
+is pristine.
+
+debian/edit-patch: a copy of dpath-edit-patch that do not assume
+  debian/rules clean unpatch the sources.
+
+Patches zone:
+100-199: Upstream patch or otherwise non-Debian issued.
+200-299: Debian patch, non Debian specific (should be forwarded upstream).
+300-399: Debian specific patch.
+
+--
+Bill Allombert <ballombe@debian.org>  Fri, 30 May 2003 23:46:27 +0200
--- libjpeg6b-6b.orig/debian/compat
+++ libjpeg6b-6b/debian/compat
@@ -0,0 +1 @@
+5
--- libjpeg6b-6b.orig/debian/changelog
+++ libjpeg6b-6b/debian/changelog
@@ -0,0 +1,230 @@
+libjpeg6b (6b-14) unstable; urgency=low
+
+  * The "Lino" release.
+  * exifautotran:
+    - fix typo in manpage. closes: #376371, thanks Reuben Thomas.
+    - preserve file mode. closes: #383379, thanks Vincent Arkesteijn.
+  * debian/control, debian/rules, debian/compat:
+    + switch to debhelper v5
+    + add libjpeg-dbg debugging package.
+  * debian/rules: remove - before "make clean" rules.
+  * Add patch 204_jpegtran_man to improve readability of manpage.
+    closes: #437453. Thanks Jorgen Grahn.
+  * jpegexiforient.1: Apply patch from Jorgen Grahn to improve formatting.
+    closes: #437446.
+
+ -- Bill Allombert <ballombe@debian.org>  Thu, 16 Aug 2007 22:59:21 +0200
+
+libjpeg6b (6b-13) unstable; urgency=low
+
+  * The "If at first you don't succeed..." release. 
+  * Change --enable-maxmem to 1024, following Guido advice.
+    This should fix the slowdowns with large files (for large < 1Gb):
+    closes: #356556, #365025, Thanks Nicolas.
+    If you hit performance problems, please set the JPEGMEM variable to
+    about half your available RAM, see jpegtran(1).
+  * Update libjpeg-progs README.Debian to reflect the new patch set and
+    the JPEGMEM feature.
+  * Bump standard version to 3.7.2.
+
+ -- Bill Allombert <ballombe@debian.org>  Fri,  5 May 2006 19:14:25 +0200
+
+libjpeg6b (6b-12) unstable; urgency=low
+
+  * The "vote for me" release
+  * Bump standard version to 3.6.2.
+  * Run  'make test' instead of home-made test-suite.
+  * Switch to debhelper v4.
+  * libjpeg is now configured with --enable-maxmem=32. This limits the memory
+    usage to 32Mb and it can be overrided by JPEGMEM. Without this flag
+    JPEGMEM is ignored and there were no limits.
+    closes: #346023. Thanks C. Scott Ananian.
+
+ -- Bill Allombert <ballombe@debian.org>  Thu,  2 Mar 2006 18:52:44 +0100
+
+libjpeg6b (6b-11) unstable; urgency=high
+
+  * The "Silencio" release
+  * exifautotran: Apply patch by Uwe Zeisberger to fix bad temporary file
+    handling.  closes: #340079
+
+ -- Bill Allombert <ballombe@debian.org>  Sun, 20 Nov 2005 20:57:07 +0100
+
+libjpeg6b (6b-10) unstable; urgency=low
+
+  * The "timeout" release.
+  * Rebuild with current toolchain.
+  * Depends on libc-dev instead of libc6-dev. closes: #294696
+    Thanks Joel Aelwyn for discussing thoroughly the matter.
+  * Instead of copying /usr/bin/libtool, we replace it by a script that
+    call libtool (using standard path search). Remarked by Jesus Climent.
+  * debian/control: remove pre-hamm cruft.
+  * Add jpegexiforient and jpegautotran by Guido Vollbeding
+    <http://sylvana.net/jpegcrop/exif_orientation.html> as proposed by Philip
+    Armstrong. closes: #257061. 
+  * Run the test-suite at build time instead of shipping it in the package:
+    - /usr/share/doc/libjpeg-progs/tests: removed.
+    - debian/control: Add Build-Depends on sharutils for uuencode.
+    - debian/libjpeg-progs.dirs: removed.
+    - debian/libjpeg-progs.test: removed.
+
+ -- Bill Allombert <ballombe@debian.org>  Tue,  1 Mar 2005 19:43:26 +0100
+
+libjpeg6b (6b-9) unstable; urgency=low
+
+  * The "I'm all for aggressive goals" release.
+  * Rebuild with new libtool. closes: #201943.
+  * patch 100_crop: Updated from Guido Vollbeding <guido@jpegclub.org>
+    to include patches 203_jpegtran_errmsg,204_perfect.
+  * patch 200_crop_man: Include 205_perfect_man.
+  * patches 203_jpegtran_errmsg, 204_perfect, 205_perfect_man: removed
+  * Add patch 203_rdppm: fix cjpeg issue with 16-bit PPM files. closes: #208937
+  * Bump standard version to 3.6.1.
+  * Update debian/edit-patch.
+
+ -- Bill Allombert <ballombe@debian.org>  Mon,  8 Sep 2003 16:22:08 +0200
+
+libjpeg6b (6b-8) unstable; urgency=low
+
+  * The "I *hate* when that happens" release.
+  * Move libjpeg62-dev to libdevel section.
+  * See debian/README.sources for detail about the (d)patch system.
+  * debian/rules: avoid to run configure twice.
+  * Add patches 204_perfect and 205_perfect_man. They implement the
+    -perfect jpegtran option as proposed by Mark W. Eichin. closes: #189027
+  * Bump standard version to 3.5.10.
+  * Use /usr/bin/libtool instead of ldconfig-generated libtool, and remove
+    various libtool related kludges, including patch 301_configure.
+    closes: #195281. Thanks Robert Millan for the suggestion.
+  * Remove patch 302_makefile. Fix debian/rules instead.
+
+ -- Bill Allombert <ballombe@debian.org>  Sat, 31 May 2003 16:16:59 +0200
+
+libjpeg6b (6b-7) unstable; urgency=low
+
+  * Rebuild with new gcc/new glibc/new debhelper.
+  * Add -g to build options according to new policy.
+  * Add support for DEB_BUILD_OPTIONS noopt. nostrip is handled by dh_strip.
+  * Bump standard version to 3.5.9.
+  * Extend description a bit (If you have a better one please email me!).
+  * Use dpatch to handle the patches.
+
+ -- Bill Allombert <ballombe@debian.org>  Sun, 16 Mar 2003 12:19:36 +0100
+
+libjpeg6b (6b-6) unstable; urgency=low
+
+  * The "Try to break sarge before it even got a name" release
+  * jpegtran: better error messages when opening files.
+    closes: #147516 Thanks Mark W. Eichin.
+  * Add debian/patch dir with my patches.
+  * Add extern "C" if we are under C++. 
+    closes: #113167 Thanks, Fredrik Jagenheim.
+  * Remove HAVE_STD{LIB,DEF}_H from jconfig.h since they are not used and
+    conflict with autoconf. closes: #109516 Thanks <Benedikt.Roth@gmx.net>
+  * Add README.Debian in /usr/share/libjpeg62-dev
+
+ -- Bill Allombert <ballombe@debian.org>  Mon,  3 Jun 2002 19:34:08 +0200
+
+libjpeg6b (6b-5) unstable; urgency=low
+
+  * jpeg-->JPEG in libjpeg-progs description.
+  * Add lib path to dh_shlibdeps to avoid warning.
+  * Apply patch from <http://sylvana.net/jpegcrop/croppatch.tar.gz> by
+    <guido@jpegclub.org> closes: #129412 Thanks, Colin Marquardt.
+
+ -- Bill Allombert <ballombe@debian.org>  Mon, 20 May 2002 11:55:22 +0200
+
+libjpeg6b (6b-4) unstable; urgency=low
+
+  * Avoid bashism in debian/rules.
+  * Update libtool to 1.3.5. (1.4 will break). 
+    closes: #52095 Thanks, <Marcus.Brinkmann@ruhr-uni-bochum.de>
+  * Patch config.guess to use version in the autotools-dev package. 
+  * Correct Section: field of libjpeg62 and libjpeg62-dev.
+
+ -- Bill Allombert <ballombe@debian.org>  Tue, 20 Nov 2001 10:23:47 +0100
+
+libjpeg6b (6b-3) unstable; urgency=low
+
+  * The "Where is ltconfig ?" release.
+  * Remove jconfig.h in debian/rules clean and do some clean up.
+  * Install libjpeg.la per Policy 11.2.
+  * Remove duplicate wizard.doc file in libjpeg62-dev. 
+  * Use dpkg-architecture instead of config.guess.
+  * Patch config.sub to use version in the autotools-dev package. 
+    closes: #85558, #120039
+  * Patch rdjpgcom.c to use locales for isprint check on comment chars.
+    closes: #116589 Thanks, Neal H Walfield <neal@cs.uml.edu>
+  * Apply patch from <http://sylvana.net/jpegcrop/transupp.c> by
+    <guido@jpegclub.org> closes: #114415 Thanks, <Jean-Marc.Notin@loria.fr>
+    
+ -- Bill Allombert <ballombe@debian.org>  Tue, 13 Nov 2001 21:41:49 +0000
+
+libjpeg6b (6b-2) unstable; urgency=low
+
+  * New Maintainer. Mark, If you want back the package, just ask!
+  * Acknowledge previous NMU: 
+    Jordi: closes: #74087, #24330, #24291
+    Colin: closes: #80752
+    Joel: closes: #25324, #27033, #28341
+  * Write source location as a valid URL in debian/copyright. 
+    closes: #118628 Thanks, Doug Porter <dsp@debian.org>.
+  * Fix formating of description of libjpeg-progs. 
+    closes: #114378 Thanks, Colin Watson <cjwatson@flatline.org.uk>.
+  * Install jpegint.h header needed by some apps. closes: #100171
+  * Remove unused/empty debian/postrm.
+    closes: #24849 Thanks, Adrian Bridgett <adrian.bridgett@zetnet.co.uk>.
+  * Install wizard.doc file. closes: #64807 Thanks <amc@arwen.cs.berkeley.edu>.
+  * Fix libjpeg-progs test.sh.
+  * Fix lintian bugs: typo in copyright, emacs user info in changelog.
+  * Fix false lintian bug: unsafe ldconfig in postinst, by reformatting.
+  * Remove "-g" from CFLAGS per Policy 11.1, hoping m68k is fixed now.
+  * Remove libtool and Makefile in debian/rules clean.
+  * Fix the test system. As a side effect, 
+    closes: #109195 Thanks Daniel Schepler <schepler@math.berkeley.edu>
+  * Standards-Version is now 3.5.6.
+
+ -- Bill Allombert <ballombe@debian.org>  Fri,  9 Nov 2001 22:40:16 +0100
+
+libjpeg6b (6b-1.3) frozen unstable; urgency=low
+
+  * Non-Maintainer Upload.
+  * Added Build-Depends.
+  * Gil Bahat <coutal@netvision.net.il> did the rest of the changes.
+  * Close bug regarding non-standard jpegs not being processed 
+    (closes: #74087).
+  * The output gifs are uncompressed, so have no UNISYS patent issues.
+    (closes: #24330, #24291).
+  * Standards-Version is now 3.0.0.
+
+ -- Jordi Mallach <jordi@debian.org>  Sat, 24 Feb 2001 22:17:38 +0100
+
+libjpeg6b (6b-1.2) frozen unstable; urgency=low (HIGH for m68k)
+
+  * Non-maintainer release.
+  * Recompile for m68k since existing djpeg binary claims all jpegs I have
+    are invalid (yet hamm djpeg has no problem with them).
+    Specifically, added "-O2 -g -Wall" to CFLAGS -- possible gcc bug?
+
+ -- Chris Lawrence <lawrencc@debian.org>  Tue, 10 Nov 1998 20:57:38 -0600
+
+libjpeg6b (6b-1.1) frozen unstable; urgency=high
+
+  * Non-maintainer release.
+  * Use upstream library soname (62).
+  * Removed libjpeg-gif package, as the source notes
+    that the GIF reading has been removed, and the GIFs written
+    do not infringe on the LZW patent.
+
+ -- Joel Klecker <espy@debian.org>  Thu, 22 Oct 1998 05:49:48 -0700
+
+libjpeg6b (6b-1) unstable; urgency=low
+
+  * New binary packages for 6b
+  * New upstream release
+
+ -- Mark Mickan <mmickan@debian.org>  Tue,  7 Jul 1998 22:27:10 +0930
+
+Local variables:
+mode: debian-changelog
+End:
--- libjpeg6b-6b.orig/debian/libjpeg62-dev.files
+++ libjpeg6b-6b/debian/libjpeg62-dev.files
@@ -0,0 +1,4 @@
+usr/include
+usr/lib/libjpeg.a
+usr/lib/libjpeg.la
+usr/lib/libjpeg.so
--- libjpeg6b-6b.orig/debian/libjpeg-progs.files
+++ libjpeg6b-6b/debian/libjpeg-progs.files
@@ -0,0 +1,2 @@
+usr/bin
+usr/share/man/man1
--- libjpeg6b-6b.orig/debian/libjpeg62-dev.docs
+++ libjpeg6b-6b/debian/libjpeg62-dev.docs
@@ -0,0 +1,3 @@
+libjpeg.doc
+structure.doc
+coderules.doc
--- libjpeg6b-6b.orig/debian/libjpeg-progs.docs
+++ libjpeg6b-6b/debian/libjpeg-progs.docs
@@ -0,0 +1,2 @@
+usage.doc
+wizard.doc
--- libjpeg6b-6b.orig/debian/libjpeg62.files
+++ libjpeg6b-6b/debian/libjpeg62.files
@@ -0,0 +1,2 @@
+/usr/lib/libjpeg.so.62.0.0
+/usr/lib/libjpeg.so.62
--- libjpeg6b-6b.orig/debian/edit-patch
+++ libjpeg6b-6b/debian/edit-patch
@@ -0,0 +1,271 @@
+#!/bin/bash
+
+set -e
+
+# Read in the user's configuration file, should it exist.
+[[ -f ~/.dpatch.conf ]] && . ~/.dpatch.conf
+
+# Populate configuration variables. First check for a pre-existing environment
+# variable which we support; that should override the configuration variable,
+# which in turn overrides the default. CLI option parsing comes later, and
+# will blindly set it to the option given therein; CLI options trump all.
+VERBOSITY=0
+DPEP_SOURCEDIR="${DPEP_SOURCEDIR:-${conf_sourcedir:-$(pwd)}}"
+DPEP_OUTDIR="${DPEP_OUTDIR:-${conf_outdir:-$DPEP_SOURCEDIR/debian/patches}}"
+DPEP_TMPDIR="${DPEP_TMPDIR:-${conf_tmpdir:-${TMPDIR:-/tmp}}}"
+DPEP_SHELL="${DPEP_SHELL:-${conf_shell:-${SHELL:-$(getent passwd $(id -un) | cut -f7- -d:)}}}"
+DPEP_KEEPTEMP="${DPEP_KEEPTEMP:-${conf_keeptemp:-0}}"
+DPEP_DESC="${DPEP_NEWDESC:-${conf_newdesc:-No description.}}"
+DPEP_TEMPLATE="${DPEP_TEMPLATE:-${conf_template:-$DPEP_SOURCEDIR/debian/patches/00template}}"
+# We special-case $DPEP_ROOTCMD later, after dpep_parse_options()
+
+# Import functions dpep_usage(), dpep_template(), dpep_parse_options(),
+# dpep_message(), dpep_parse_longopt_value() 
+. /usr/share/dpatch/dpatch-edit-patch.functions
+
+dpep_parse_options "$@" || true
+
+# We special-case $DPEP_ROOTCMD here; if fakeroot doesn't exist and we haven't
+# been told explicitly what it should be, error out. (I refuse to use sudo as
+# any kind of default, even a fallback if fakeroot doesn't exist - way too
+# dangerous). We do this after option parsing, to ensure that they can supply a
+# ROOTCMD on the CLI.
+if [[ -z "$DPEP_ROOTCMD" ]]; then
+    # We're only here if $DPEP_ROOTCMD hasn't already been set via either a CLI
+    # argument or the environment variable itself.
+    if [[ ! -z "$conf_rootcmd" ]]; then
+	# If we're here, the configuration variable has been set
+	DPEP_ROOTCMD="$conf_rootcmd"
+    elif command -v fakeroot > /dev/null 2>&1; then
+	# If we're here, nothing's been set, but fakeroot exists.
+	DPEP_ROOTCMD="fakeroot"
+    else
+	# We're here, nothing's set, fakeroot's not found. Bail.
+	dpep_message error " "
+	printf "fakeroot is not installed, nor has the option --rootcmd been given, nor has the\n"
+	printf "environment variable \$DPEP_ROOTCMD been set, nor has the configuration file\n"
+	printf "variable conf_rootcmd been set. Please see the manual page for more details.\n"
+	exit 1
+    fi
+fi
+
+# All argument and option parsing has been done. Time to accomplish something.
+# Change to source directory
+cd "$DPEP_SOURCEDIR"
+
+# $PWD: $DPEP_SOURCEDIR
+if [[ ! -e "debian/rules" ]]; then
+# Check to make sure we're in the toplevel directory of a Debian package;
+# if not, error out.
+    dpep_message error "\"$DPEP_SOURCEDIR\" is not the toplevel directory of a Debian package, aborting."
+    exit 1
+fi
+
+# Check to see whether or not $DPEP_PATCH ends with .dpatch
+if [[ "${DPEP_PATCH}" = "${DPEP_PATCH%%.dpatch}" ]]; then
+    # If it doesn't have .dpatch, append it.
+    DPEP_PATCH="${DPEP_PATCH}.dpatch"
+fi
+
+# $PWD: $DPEP_SOURCEDIR
+if [[ -e "$DPEP_OUTDIR/$DPEP_PATCH" ]]; then
+# Check to see if the patch we're told to edit exists; if not, we'll be
+# creating it.
+    # The patch does already exist, let them know this.
+    dpep_message norm "* $DPEP_OUTDIR/$DPEP_PATCH exists, this patch will be updated."
+    # Also set this ... later on, we'll need to differentiate between editing
+    # an existing patch, and creating a new one.
+    DPEP_EDITPATCH=1
+    if [[ ! -z "$DPEP_BASEPATCH" ]]; then
+	# Even though we're editing an already-existing patch, the user has
+	# supplied a base-patch. Warn them that we will be ignoring this.
+	dpep_message warn "We are editing an already-existing patch, but a base-patch of $DPEP_BASEPATCH has been supplied - ignoring."
+	# We patch up to $DPEP_BASEPATCH in the workdir later, so we assign to
+	# it the patch we'll be editing
+	DPEP_BASEPATCH="$DPEP_PATCH"
+    else
+	# They haven't supplied a base-patch, which is nice and sane, so we
+	# assign to it the patch we'll be editing, for the same reason as
+	# above; we'll be applying it to the working directory.
+	DPEP_BASEPATCH="$DPEP_PATCH"
+    fi
+else
+    # Patch doesn't exist, we aren't editing it.
+    DPEP_EDITPATCH=0
+    dpep_message norm "* $DPEP_OUTDIR/$DPEP_PATCH does not exist, it will be created as a new dpatch."
+    # Check to ensure that, if we've been given a base-patch, it exists;
+    # otherwise we really need to abort. If we haven't been supplied one,
+    # that's fine
+    if [[ ! -z "$DPEP_BASEPATCH" ]]; then
+	if [[ "$DPEP_BASEPATCH" = "${DPEP_BASEPATCH%%.dpatch}" ]]; then
+	    # The user didn't supply a .dpatch extension, so we supply it.
+	    DPEP_BASEPATCH="$DPEP_BASEPATCH.dpatch"
+	fi
+	if [[ ! -e "debian/patches/$DPEP_BASEPATCH" ]]; then
+	    dpep_message error "Base-patch $(pwd)/debian/patches/$DPEP_BASEPATCH does not exist, aborting."
+	fi
+    fi
+fi
+
+# Start preparing the working copy.
+# $PWD: $DPEP_SOURCEDIR
+# Sanity checking to ensure that our temporary directory exists and is
+# writable.
+if [[ ! -d "$DPEP_TMPDIR" ]]; then
+    dpep_message error "Temporary directory $DPEP_TMPDIR does not exist, aborting."
+    exit 1
+elif [[ ! -w "$DPEP_TMPDIR" ]]; then
+    dpep_message error "Temporary directory $DPEP_TMPDIR is not writable, aborting."
+    exit 1
+fi
+
+# $PWD: $DPEP_SOURCEDIR
+# Hopefully mktemp(1), part of debianutils, does the Right Thing :) We're
+# pretty sure it does :)
+WORKDIR="$(TMPDIR=$DPEP_TMPDIR mktemp -d -p /tmp dpep.XXXXXX)"
+dpep_message debug1 "Working directory is $WORKDIR"
+
+# $PWD: $DPEP_SOURCEDIR
+# Copy, clean, and clone $DPEP_SOUREDIR
+dpep_message norm "* Cleaning $DPEP_SOURCEDIR"
+cd "$DPEP_SOURCEDIR"
+$DPEP_ROOTCMD debian/rules clean unpatch
+
+if [[ ! -z "$DPEP_BASEPATCH" ]]; then
+    if ! egrep "[[:space:]]*(${DPEP_BASEPATCH}|${DPEP_BASEPATCH%%.dpatch})[[:space:]]*" debian/patches/00list > /dev/null 2>&1; then
+	if [[ "$DPEP_EDITPATCH" = 1 ]]; then
+	    dpep_message warn "$DPEP_PATCH is not listed in debian/patches/00list, no other patches will be applied to the working directory."
+	else
+	    dpep_message error "Base-patch is not listed in debian/patches/00list, aborting."
+	    exit 1
+	fi
+    else
+	dpep_message norm "* Applying patches"
+	LASTPATCHDONE=0
+	for patch in $(cat debian/patches/00list | grep -v ^\#); do
+	    # Check to see if we're editing a patch; if we are, we don't want to
+	    # apply it in the clean directory which won't be edited. If we did
+	    # apply it, we would only pick up differences that they *just* made,
+	    # as opposed to updating the enire patch.
+	    [[ "$DPEP_EDITPATCH" = "1" && "${patch%%.dpatch}.dpatch" = "$DPEP_PATCH" ]] && LASTPATCHDONE=1
+	    [[ "$LASTPATCHDONE" = "1" ]] && break
+	    printf "$(basename $0): ** Applying patch ${patch%%.dpatch}.dpatch ... "
+	    APPLY_PATCHDIR="$(dirname "${patch%%.dpatch}.dpatch")"
+	    stamp="debian/patched/${patch%%.dpatch}.dpatch"
+	    [[ ! -d "debian/patched/$APPLY_PATCHDIR" ]] && mkdir -p "debian/patched/$APPLY_PATCHDIR"
+	    chmod +x "debian/patches/${patch%%.dpatch}.dpatch"
+	    if ! "debian/patches/${patch%%.dpatch}.dpatch" -patch > "$stamp.new" 2>&1; then
+		printf "failed.\n"
+		dpep_message error "Patch debian/patches/${patch%%.dpatch}.dpatch did not apply cleanly, aborting."
+		exit 1
+	    else
+		mv "$stamp.new" "$stamp"
+		touch "$stamp"
+		printf "applied cleanly.\n"
+	    fi
+	    if [[ "$DPEP_BASEPATCH" = "${patch%%.dpatch}.dpatch" ]]; then
+		LASTPATCHDONE=1
+	    fi
+	done
+    fi
+else
+    dpep_message warn "* No base-patch supplied, not applying any patches."
+fi
+
+dpep_message norm "* Copying $DPEP_SOURCEDIR to work directory."
+cd "$WORKDIR"
+cp -a "$DPEP_SOURCEDIR" "$(basename $DPEP_SOURCEDIR)"
+
+
+# Change to the workdirectory, apply the patch we're editing if we're
+# editing one, and launch an interactive shell.
+cd "$WORKDIR/$(basename $DPEP_SOURCEDIR)"
+if [[ "$DPEP_EDITPATCH" = "1" ]]; then
+    dpep_message norm "* Applying current $DPEP_PATCH for editing."
+    chmod +x debian/patches/$DPEP_PATCH
+    if ! debian/patches/$DPEP_PATCH -patch > /dev/null; then
+	dpep_message warn "Could not apply the patch we want to edit -- not aborting, as you may want to work with the .rejs."
+    fi
+fi
+cat <<EOF
+
+$(basename $0):
+
+Now launching an interactive shell in your work directory. Edit your files.
+When you are done, exit the shell. When you exit the shell, your patch will be
+automatically updated based on the changes in your work directory.
+
+If you wish to abort the process, exit the shell such that it returns an exit
+code of "230". This is typically done by exiting the shell with the command
+'exit 230'.
+EOF
+$DPEP_SHELL; EXITVAL="$?"
+if [[ "$EXITVAL" = "230" ]]; then
+    dpep_message error "Shell exited with an exit value of 230, aborting."
+    dpep_cleanup
+    exit 1
+elif [[ "$EXITVAL" != "0" ]]; then
+    dpep_message warn "Shell exited with an exit value other than 0."
+fi
+cd "$WORKDIR"
+
+# Okay, they've exited the shell in a reasonable manner, and as such we're
+# free to create or update the patch.
+DIFFHOLDER="$(tempfile -d "$WORKDIR" -p "dpep." -s ".diff")"
+dpep_message debug1 "Diff temporary file is $DIFFHOLDER"
+diff -urNad "$DPEP_SOURCEDIR" "$(basename "$DPEP_SOURCEDIR")" > "$DIFFHOLDER" || true
+
+# Diff created, let's switch back to the original directory, and start the
+# process of updating or creating the patch.
+cd "$DPEP_SOURCEDIR"
+if [[ "$DPEP_EDITPATCH" = "0" ]]; then
+    # We're creating a new patch, so this is relatively easy.
+    dpep_message norm "* Creating new patch $DPEP_OUTDIR/$DPEP_PATCH"
+    # We don't know for sure that any directories are created, so let's create
+    # them now.
+
+    PATCHDIR="$DPEP_OUTDIR/$(dirname "$DPEP_PATCH")"
+    NEWPATCH="$DPEP_OUTDIR/$DPEP_PATCH"
+
+    [[ ! -d "$PATCHDIR" ]] && mkdir -p "$PATCHDIR"
+    if [[ ! -f "$DPEP_TEMPLATE" ]]; then
+	dpep_message warn "$template does not exist, using hardcoded default."
+	dpep_template_hardcoded "$NEWPATCH"
+    else
+	dpep_message norm "Using template $template"
+	dpep_template_apply "$DPEP_TEMPLATE" "$NEWPATCH" "$DPEP_DESC"
+    fi
+    # Okay, headers and shell snippets all set up. Now copy the actual patch text.
+    cat "$DIFFHOLDER" >> "$NEWPATCH"
+    dpep_message norm "$NEWPATCH created."
+else
+    # Damnit, we're editing a patch. This is _never_ fun :)
+    OLDPATCH="$DPEP_OUTDIR/$DPEP_PATCH"
+    dpep_message norm "Updating patch $OLDPATCH"
+    # Need another temporary file.
+    NEWPATCH="$(tempfile -d "$WORKDIR")"
+    DPEP_TAGLINENUM="$(grep -n '^@DPATCH@$' "$OLDPATCH" | head -1 | cut -f1 -d:)"
+    if [ "$DPEP_TAGLINENUM" ]; then
+	# They have our tag, so we can preserve their headers.
+	dpep_message norm "@DPATCH@ tag found, preserving dpatch header."
+	head -n "$DPEP_TAGLINENUM" "$OLDPATCH" > "$NEWPATCH"
+    elif [[ -e "$DPEP_TEMPLATE" ]]; then
+	# Okay, they don't have a tag - damn them. But they at least have a
+	# template.
+	dpep_message warn "@DPATCH@ tag not found, using $DPEP_TEMPLATE"
+	dpep_template_apply "$DPEP_TEMPLATE" "$OLDPATCH" "$DPEP_DESC"
+    else
+	# They have neither a @DPATCH@ tag, *NOR* a template. Damn, they just suck.
+	dpep_message warn "@DPATCH@ tag not found, $DPEP_TEMPLATE not found. Using hardcoded default."
+	dpep_template_hardcoded "$NEWPATCH"
+    fi
+    # Okay, the headers and shell snippets are in place. Move the diff there now.
+    cat "$DIFFHOLDER" >> "$NEWPATCH"
+    mv "$NEWPATCH" "$OLDPATCH"
+    dpep_message norm "$OLDPATCH updated."
+fi
+# chmod +x the dpatch, just in case.
+chmod +x "$DPEP_OUTDIR/$DPEP_PATCH"
+
+# Okay, we're all done. Do the cleanup.
+dpep_cleanup
--- libjpeg6b-6b.orig/debian/check-pristine
+++ libjpeg6b-6b/debian/check-pristine
@@ -0,0 +1,14 @@
+#! /bin/sh
+if test ! -d debian; then 
+  echo "cannot find debian dir" >&2
+  exit 2
+fi
+set -e
+fakeroot debian/rules clean
+debian/rules unpatch
+cd ..
+tar zxf libjpeg6b_6b.orig.tar.gz 
+cd jpeg-6b
+find . -path debian -prune -o -exec diff -u '{}' '../libjpeg6b-6b/{}' ';'
+cd ..
+rm -r jpeg-6b
--- libjpeg6b-6b.orig/debian/libjpeg62-dev.examples
+++ libjpeg6b-6b/debian/libjpeg62-dev.examples
@@ -0,0 +1 @@
+example.c
--- libjpeg6b-6b.orig/debian/patches/202_jpeglib.h_c++.dpatch
+++ libjpeg6b-6b/debian/patches/202_jpeglib.h_c++.dpatch
@@ -0,0 +1,38 @@
+#! /bin/sh -e
+
+# DP: Add extern "C" to jpeglib.h
+
+case "$1" in
+    -patch) patch -f --no-backup-if-mismatch -p1 < $0;;
+    -unpatch) patch -f --no-backup-if-mismatch -R -p1 < $0;;
+    *)
+        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+        exit 1
+esac
+exit 0
+@DPATCH@
+diff -ur -x debian/* jpeg-6b/jpeglib.h libjpeg6b-6b/jpeglib.h
+--- jpeg-6b/jpeglib.h	Sat Feb 21 20:48:14 1998
++++ libjpeg6b-6b/jpeglib.h	Wed Feb 26 01:04:42 2003
+@@ -13,6 +13,10 @@
+ #ifndef JPEGLIB_H
+ #define JPEGLIB_H
+ 
++#ifdef __cplusplus
++extern "C" {
++#endif
++
+ /*
+  * First we include the configuration files that record how this
+  * installation of the JPEG library is set up.  jconfig.h can be
+@@ -1091,6 +1095,10 @@
+ #ifdef JPEG_INTERNALS
+ #include "jpegint.h"		/* fetch private declarations */
+ #include "jerror.h"		/* fetch error codes too */
++#endif
++
++#ifdef __cplusplus
++}
+ #endif
+ 
+ #endif /* JPEGLIB_H */
--- libjpeg6b-6b.orig/debian/patches/100_crop.dpatch
+++ libjpeg6b-6b/debian/patches/100_crop.dpatch
@@ -0,0 +1,1896 @@
+#! /bin/sh -e
+
+# DP: Lossless-crop patch from <http://sylvana.net/jpegcrop/croppatch.tar.gz>
+# DP: by <guido@jpegclub.org>.
+
+case "$1" in
+    -patch) patch -f --no-backup-if-mismatch -p1 < $0;;
+    -unpatch) patch -f --no-backup-if-mismatch -R -p1 < $0;;
+    *)
+        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+        exit 1
+esac
+exit 0
+@DPATCH@
+diff -urNad /home/bill/debian/libjpeg/libjpeg6b-6b/jerror.h libjpeg6b-6b/jerror.h
+--- /home/bill/debian/libjpeg/libjpeg6b-6b/jerror.h	2003-09-22 18:15:48.000000000 +0200
++++ libjpeg6b-6b/jerror.h	2003-09-22 18:16:12.000000000 +0200
+@@ -45,6 +45,7 @@
+ JMESSAGE(JERR_BAD_ALLOC_CHUNK, "MAX_ALLOC_CHUNK is wrong, please fix")
+ JMESSAGE(JERR_BAD_BUFFER_MODE, "Bogus buffer control mode")
+ JMESSAGE(JERR_BAD_COMPONENT_ID, "Invalid component ID %d in SOS")
++JMESSAGE(JERR_BAD_CROP_SPEC, "Invalid crop request")
+ JMESSAGE(JERR_BAD_DCT_COEF, "DCT coefficient out of range")
+ JMESSAGE(JERR_BAD_DCTSIZE, "IDCT output block size %d not supported")
+ JMESSAGE(JERR_BAD_HUFF_TABLE, "Bogus Huffman table definition")
+diff -urNad /home/bill/debian/libjpeg/libjpeg6b-6b/jpegtran.c libjpeg6b-6b/jpegtran.c
+--- /home/bill/debian/libjpeg/libjpeg6b-6b/jpegtran.c	2003-09-22 18:15:48.000000000 +0200
++++ libjpeg6b-6b/jpegtran.c	2003-09-22 18:16:22.000000000 +0200
+@@ -1,7 +1,7 @@
+ /*
+  * jpegtran.c
+  *
+- * Copyright (C) 1995-1997, Thomas G. Lane.
++ * Copyright (C) 1995-2001, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+@@ -64,8 +64,10 @@
+ #endif
+ #if TRANSFORMS_SUPPORTED
+   fprintf(stderr, "Switches for modifying the image:\n");
++  fprintf(stderr, "  -crop WxH+X+Y  Crop to a rectangular subarea\n");
+   fprintf(stderr, "  -grayscale     Reduce to grayscale (omit color data)\n");
+   fprintf(stderr, "  -flip [horizontal|vertical]  Mirror image (left-right or top-bottom)\n");
++  fprintf(stderr, "  -perfect       Fail if there is non-transformable edge blocks\n");
+   fprintf(stderr, "  -rotate [90|180|270]         Rotate image (degrees clockwise)\n");
+   fprintf(stderr, "  -transpose     Transpose image\n");
+   fprintf(stderr, "  -transverse    Transverse transpose image\n");
+@@ -133,7 +135,9 @@
+   copyoption = JCOPYOPT_DEFAULT;
+   transformoption.transform = JXFORM_NONE;
+   transformoption.trim = FALSE;
++  transformoption.perfect = FALSE;
+   transformoption.force_grayscale = FALSE;
++  transformoption.crop = FALSE;
+   cinfo->err->trace_level = 0;
+ 
+   /* Scan command line options, adjust parameters */
+@@ -160,7 +164,7 @@
+       exit(EXIT_FAILURE);
+ #endif
+ 
+-    } else if (keymatch(arg, "copy", 1)) {
++    } else if (keymatch(arg, "copy", 2)) {
+       /* Select which extra markers to copy. */
+       if (++argn >= argc)	/* advance to next argument */
+ 	usage();
+@@ -173,6 +177,20 @@
+       } else
+ 	usage();
+ 
++    } else if (keymatch(arg, "crop", 2)) {
++      /* Perform lossless cropping. */
++#if TRANSFORMS_SUPPORTED
++      if (++argn >= argc)	/* advance to next argument */
++	usage();
++      if (! jtransform_parse_crop_spec(&transformoption, argv[argn])) {
++	fprintf(stderr, "%s: bogus -crop argument '%s'\n",
++		progname, argv[argn]);
++	exit(EXIT_FAILURE);
++      }
++#else
++      select_transform(JXFORM_NONE);	/* force an error */
++#endif
++
+     } else if (keymatch(arg, "debug", 1) || keymatch(arg, "verbose", 1)) {
+       /* Enable debug printouts. */
+       /* On first -d, print version identification */
+@@ -233,7 +251,12 @@
+ 	usage();
+       outfilename = argv[argn];	/* save it away for later use */
+ 
+-    } else if (keymatch(arg, "progressive", 1)) {
++    } else if (keymatch(arg, "perfect", 2)) {
++      /* Fail if there is any partial edge MCUs that the transform can't
++       * handle. */
++      transformoption.perfect = TRUE;
++
++    } else if (keymatch(arg, "progressive", 2)) {
+       /* Select simple progressive mode. */
+ #ifdef C_PROGRESSIVE_SUPPORTED
+       simple_progressive = TRUE;
+@@ -342,8 +365,10 @@
+   jvirt_barray_ptr * src_coef_arrays;
+   jvirt_barray_ptr * dst_coef_arrays;
+   int file_index;
+-  FILE * input_file;
+-  FILE * output_file;
++  /* We assume all-in-memory processing and can therefore use only a
++   * single file pointer for sequential input and output operation. 
++   */
++  FILE * fp;
+ 
+   /* On Mac, fetch a command line. */
+ #ifdef USE_CCOMMAND
+@@ -406,24 +431,13 @@
+ 
+   /* Open the input file. */
+   if (file_index < argc) {
+-    if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {
+-      fprintf(stderr, "%s: can't open %s\n", progname, argv[file_index]);
++    if ((fp = fopen(argv[file_index], READ_BINARY)) == NULL) {
++      fprintf(stderr, "%s: can't open %s for reading\n", progname, argv[file_index]);
+       exit(EXIT_FAILURE);
+     }
+   } else {
+     /* default input file is stdin */
+-    input_file = read_stdin();
+-  }
+-
+-  /* Open the output file. */
+-  if (outfilename != NULL) {
+-    if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {
+-      fprintf(stderr, "%s: can't open %s\n", progname, outfilename);
+-      exit(EXIT_FAILURE);
+-    }
+-  } else {
+-    /* default output file is stdout */
+-    output_file = write_stdout();
++    fp = read_stdin();
+   }
+ 
+ #ifdef PROGRESS_REPORT
+@@ -431,7 +445,7 @@
+ #endif
+ 
+   /* Specify data source for decompression */
+-  jpeg_stdio_src(&srcinfo, input_file);
++  jpeg_stdio_src(&srcinfo, fp);
+ 
+   /* Enable saving of extra markers that we want to copy */
+   jcopy_markers_setup(&srcinfo, copyoption);
+@@ -443,6 +457,15 @@
+    * jpeg_read_coefficients so that memory allocation will be done right.
+    */
+ #if TRANSFORMS_SUPPORTED
++  /* Fails right away if -perfect is given and transformation is not perfect.
++   */
++  if (transformoption.perfect &&
++      !jtransform_perfect_transform(srcinfo.image_width, srcinfo.image_height,
++      srcinfo.max_h_samp_factor * DCTSIZE, srcinfo.max_v_samp_factor * DCTSIZE,
++      transformoption.transform)) {
++    fprintf(stderr, "%s: transformation is not perfect\n", progname);
++    exit(EXIT_FAILURE);
++  }
+   jtransform_request_workspace(&srcinfo, &transformoption);
+ #endif
+ 
+@@ -463,11 +486,32 @@
+   dst_coef_arrays = src_coef_arrays;
+ #endif
+ 
++  /* Close input file, if we opened it.
++   * Note: we assume that jpeg_read_coefficients consumed all input
++   * until JPEG_REACHED_EOI, and that jpeg_finish_decompress will
++   * only consume more while (! cinfo->inputctl->eoi_reached).
++   * We cannot call jpeg_finish_decompress here since we still need the
++   * virtual arrays allocated from the source object for processing.
++   */
++  if (fp != stdin)
++    fclose(fp);
++
++  /* Open the output file. */
++  if (outfilename != NULL) {
++    if ((fp = fopen(outfilename, WRITE_BINARY)) == NULL) {
++      fprintf(stderr, "%s: can't open %s for writing\n", progname, outfilename);
++      exit(EXIT_FAILURE);
++    }
++  } else {
++    /* default output file is stdout */
++    fp = write_stdout();
++  }
++
+   /* Adjust default compression parameters by re-parsing the options */
+   file_index = parse_switches(&dstinfo, argc, argv, 0, TRUE);
+ 
+   /* Specify data destination for compression */
+-  jpeg_stdio_dest(&dstinfo, output_file);
++  jpeg_stdio_dest(&dstinfo, fp);
+ 
+   /* Start compressor (note no image data is actually written here) */
+   jpeg_write_coefficients(&dstinfo, dst_coef_arrays);
+@@ -488,11 +532,9 @@
+   (void) jpeg_finish_decompress(&srcinfo);
+   jpeg_destroy_decompress(&srcinfo);
+ 
+-  /* Close files, if we opened them */
+-  if (input_file != stdin)
+-    fclose(input_file);
+-  if (output_file != stdout)
+-    fclose(output_file);
++  /* Close output file, if we opened it */
++  if (fp != stdout)
++    fclose(fp);
+ 
+ #ifdef PROGRESS_REPORT
+   end_progress_monitor((j_common_ptr) &dstinfo);
+diff -urNad /home/bill/debian/libjpeg/libjpeg6b-6b/transupp.c libjpeg6b-6b/transupp.c
+--- /home/bill/debian/libjpeg/libjpeg6b-6b/transupp.c	2003-09-22 18:15:49.000000000 +0200
++++ libjpeg6b-6b/transupp.c	2003-09-22 18:16:28.000000000 +0200
+@@ -1,7 +1,7 @@
+ /*
+  * transupp.c
+  *
+- * Copyright (C) 1997, Thomas G. Lane.
++ * Copyright (C) 1997-2001, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+@@ -20,6 +20,7 @@
+ #include "jinclude.h"
+ #include "jpeglib.h"
+ #include "transupp.h"		/* My own external interface */
++#include <ctype.h>		/* to declare isdigit() */
+ 
+ 
+ #if TRANSFORMS_SUPPORTED
+@@ -28,7 +29,8 @@
+  * Lossless image transformation routines.  These routines work on DCT
+  * coefficient arrays and thus do not require any lossy decompression
+  * or recompression of the image.
+- * Thanks to Guido Vollbeding for the initial design and code of this feature.
++ * Thanks to Guido Vollbeding for the initial design and code of this feature,
++ * and to Ben Jackson for introducing the cropping feature.
+  *
+  * Horizontal flipping is done in-place, using a single top-to-bottom
+  * pass through the virtual source array.  It will thus be much the
+@@ -42,6 +44,13 @@
+  * arrays for most of the transforms.  That could result in much thrashing
+  * if the image is larger than main memory.
+  *
++ * If cropping or trimming is involved, the destination arrays may be smaller
++ * than the source arrays.  Note it is not possible to do horizontal flip
++ * in-place when a nonzero Y crop offset is specified, since we'd have to move
++ * data from one block row to another but the virtual array manager doesn't
++ * guarantee we can touch more than one row at a time.  So in that case,
++ * we have to use a separate destination array.
++ *
+  * Some notes about the operating environment of the individual transform
+  * routines:
+  * 1. Both the source and destination virtual arrays are allocated from the
+@@ -54,20 +63,65 @@
+  *    and we may as well take that as the effective iMCU size.
+  * 4. When "trim" is in effect, the destination's dimensions will be the
+  *    trimmed values but the source's will be untrimmed.
+- * 5. All the routines assume that the source and destination buffers are
++ * 5. When "crop" is in effect, the destination's dimensions will be the
++ *    cropped values but the source's will be uncropped.  Each transform
++ *    routine is responsible for picking up source data starting at the
++ *    correct X and Y offset for the crop region.  (The X and Y offsets
++ *    passed to the transform routines are measured in iMCU blocks of the
++ *    destination.)
++ * 6. All the routines assume that the source and destination buffers are
+  *    padded out to a full iMCU boundary.  This is true, although for the
+  *    source buffer it is an undocumented property of jdcoefct.c.
+- * Notes 2,3,4 boil down to this: generally we should use the destination's
+- * dimensions and ignore the source's.
+  */
+ 
+ 
+ LOCAL(void)
+-do_flip_h (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+-	   jvirt_barray_ptr *src_coef_arrays)
+-/* Horizontal flip; done in-place, so no separate dest array is required */
++do_crop (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
++	 JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
++	 jvirt_barray_ptr *src_coef_arrays,
++	 jvirt_barray_ptr *dst_coef_arrays)
++/* Crop.  This is only used when no rotate/flip is requested with the crop. */
+ {
+-  JDIMENSION MCU_cols, comp_width, blk_x, blk_y;
++  JDIMENSION dst_blk_y, x_crop_blocks, y_crop_blocks;
++  int ci, offset_y;
++  JBLOCKARRAY src_buffer, dst_buffer;
++  jpeg_component_info *compptr;
++
++  /* We simply have to copy the right amount of data (the destination's
++   * image size) starting at the given X and Y offsets in the source.
++   */
++  for (ci = 0; ci < dstinfo->num_components; ci++) {
++    compptr = dstinfo->comp_info + ci;
++    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
++    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
++    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
++	 dst_blk_y += compptr->v_samp_factor) {
++      dst_buffer = (*srcinfo->mem->access_virt_barray)
++	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
++	 (JDIMENSION) compptr->v_samp_factor, TRUE);
++      src_buffer = (*srcinfo->mem->access_virt_barray)
++	((j_common_ptr) srcinfo, src_coef_arrays[ci],
++	 dst_blk_y + y_crop_blocks,
++	 (JDIMENSION) compptr->v_samp_factor, FALSE);
++      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
++	jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,
++			dst_buffer[offset_y],
++			compptr->width_in_blocks);
++      }
++    }
++  }
++}
++
++
++LOCAL(void)
++do_flip_h_no_crop (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
++		   JDIMENSION x_crop_offset,
++		   jvirt_barray_ptr *src_coef_arrays)
++/* Horizontal flip; done in-place, so no separate dest array is required.
++ * NB: this only works when y_crop_offset is zero.
++ */
++{
++  JDIMENSION MCU_cols, comp_width, blk_x, blk_y, x_crop_blocks;
+   int ci, k, offset_y;
+   JBLOCKARRAY buffer;
+   JCOEFPTR ptr1, ptr2;
+@@ -79,17 +133,19 @@
+    * mirroring by changing the signs of odd-numbered columns.
+    * Partial iMCUs at the right edge are left untouched.
+    */
+-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
++  MCU_cols = srcinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+ 
+   for (ci = 0; ci < dstinfo->num_components; ci++) {
+     compptr = dstinfo->comp_info + ci;
+     comp_width = MCU_cols * compptr->h_samp_factor;
++    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+     for (blk_y = 0; blk_y < compptr->height_in_blocks;
+ 	 blk_y += compptr->v_samp_factor) {
+       buffer = (*srcinfo->mem->access_virt_barray)
+ 	((j_common_ptr) srcinfo, src_coef_arrays[ci], blk_y,
+ 	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
++	/* Do the mirroring */
+ 	for (blk_x = 0; blk_x * 2 < comp_width; blk_x++) {
+ 	  ptr1 = buffer[offset_y][blk_x];
+ 	  ptr2 = buffer[offset_y][comp_width - blk_x - 1];
+@@ -105,6 +161,79 @@
+ 	    *ptr2++ = -temp1;
+ 	  }
+ 	}
++	if (x_crop_blocks > 0) {
++	  /* Now left-justify the portion of the data to be kept.
++	   * We can't use a single jcopy_block_row() call because that routine
++	   * depends on memcpy(), whose behavior is unspecified for overlapping
++	   * source and destination areas.  Sigh.
++	   */
++	  for (blk_x = 0; blk_x < compptr->width_in_blocks; blk_x++) {
++	    jcopy_block_row(buffer[offset_y] + blk_x + x_crop_blocks,
++			    buffer[offset_y] + blk_x,
++			    (JDIMENSION) 1);
++	  }
++	}
++      }
++    }
++  }
++}
++
++
++LOCAL(void)
++do_flip_h (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
++	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
++	   jvirt_barray_ptr *src_coef_arrays,
++	   jvirt_barray_ptr *dst_coef_arrays)
++/* Horizontal flip in general cropping case */
++{
++  JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;
++  JDIMENSION x_crop_blocks, y_crop_blocks;
++  int ci, k, offset_y;
++  JBLOCKARRAY src_buffer, dst_buffer;
++  JBLOCKROW src_row_ptr, dst_row_ptr;
++  JCOEFPTR src_ptr, dst_ptr;
++  jpeg_component_info *compptr;
++
++  /* Here we must output into a separate array because we can't touch
++   * different rows of a single virtual array simultaneously.  Otherwise,
++   * this is essentially the same as the routine above.
++   */
++  MCU_cols = srcinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
++
++  for (ci = 0; ci < dstinfo->num_components; ci++) {
++    compptr = dstinfo->comp_info + ci;
++    comp_width = MCU_cols * compptr->h_samp_factor;
++    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
++    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
++    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
++	 dst_blk_y += compptr->v_samp_factor) {
++      dst_buffer = (*srcinfo->mem->access_virt_barray)
++	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
++	 (JDIMENSION) compptr->v_samp_factor, TRUE);
++      src_buffer = (*srcinfo->mem->access_virt_barray)
++	((j_common_ptr) srcinfo, src_coef_arrays[ci],
++	 dst_blk_y + y_crop_blocks,
++	 (JDIMENSION) compptr->v_samp_factor, FALSE);
++      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
++	dst_row_ptr = dst_buffer[offset_y];
++	src_row_ptr = src_buffer[offset_y];
++	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
++	  if (x_crop_blocks + dst_blk_x < comp_width) {
++	    /* Do the mirrorable blocks */
++	    dst_ptr = dst_row_ptr[dst_blk_x];
++	    src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
++	    /* this unrolled loop doesn't need to know which row it's on... */
++	    for (k = 0; k < DCTSIZE2; k += 2) {
++	      *dst_ptr++ = *src_ptr++;	 /* copy even column */
++	      *dst_ptr++ = - *src_ptr++; /* copy odd column with sign change */
++	    }
++	  } else {
++	    /* Copy last partial block(s) verbatim */
++	    jcopy_block_row(src_row_ptr + dst_blk_x + x_crop_blocks,
++			    dst_row_ptr + dst_blk_x,
++			    (JDIMENSION) 1);
++	  }
++	}
+       }
+     }
+   }
+@@ -113,11 +242,13 @@
+ 
+ LOCAL(void)
+ do_flip_v (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
++	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+ 	   jvirt_barray_ptr *src_coef_arrays,
+ 	   jvirt_barray_ptr *dst_coef_arrays)
+ /* Vertical flip */
+ {
+   JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
++  JDIMENSION x_crop_blocks, y_crop_blocks;
+   int ci, i, j, offset_y;
+   JBLOCKARRAY src_buffer, dst_buffer;
+   JBLOCKROW src_row_ptr, dst_row_ptr;
+@@ -131,33 +262,38 @@
+    * of odd-numbered rows.
+    * Partial iMCUs at the bottom edge are copied verbatim.
+    */
+-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
++  MCU_rows = srcinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+ 
+   for (ci = 0; ci < dstinfo->num_components; ci++) {
+     compptr = dstinfo->comp_info + ci;
+     comp_height = MCU_rows * compptr->v_samp_factor;
++    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
++    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+ 	 dst_blk_y += compptr->v_samp_factor) {
+       dst_buffer = (*srcinfo->mem->access_virt_barray)
+ 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+ 	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+-      if (dst_blk_y < comp_height) {
++      if (y_crop_blocks + dst_blk_y < comp_height) {
+ 	/* Row is within the mirrorable area. */
+ 	src_buffer = (*srcinfo->mem->access_virt_barray)
+ 	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+-	   comp_height - dst_blk_y - (JDIMENSION) compptr->v_samp_factor,
++	   comp_height - y_crop_blocks - dst_blk_y -
++	   (JDIMENSION) compptr->v_samp_factor,
+ 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+       } else {
+ 	/* Bottom-edge blocks will be copied verbatim. */
+ 	src_buffer = (*srcinfo->mem->access_virt_barray)
+-	  ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_y,
++	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
++	   dst_blk_y + y_crop_blocks,
+ 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+       }
+       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+-	if (dst_blk_y < comp_height) {
++	if (y_crop_blocks + dst_blk_y < comp_height) {
+ 	  /* Row is within the mirrorable area. */
+ 	  dst_row_ptr = dst_buffer[offset_y];
+ 	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
++	  src_row_ptr += x_crop_blocks;
+ 	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+ 	       dst_blk_x++) {
+ 	    dst_ptr = dst_row_ptr[dst_blk_x];
+@@ -173,7 +309,8 @@
+ 	  }
+ 	} else {
+ 	  /* Just copy row verbatim. */
+-	  jcopy_block_row(src_buffer[offset_y], dst_buffer[offset_y],
++	  jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,
++			  dst_buffer[offset_y],
+ 			  compptr->width_in_blocks);
+ 	}
+       }
+@@ -184,11 +321,12 @@
+ 
+ LOCAL(void)
+ do_transpose (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
++	      JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+ 	      jvirt_barray_ptr *src_coef_arrays,
+ 	      jvirt_barray_ptr *dst_coef_arrays)
+ /* Transpose source into destination */
+ {
+-  JDIMENSION dst_blk_x, dst_blk_y;
++  JDIMENSION dst_blk_x, dst_blk_y, x_crop_blocks, y_crop_blocks;
+   int ci, i, j, offset_x, offset_y;
+   JBLOCKARRAY src_buffer, dst_buffer;
+   JCOEFPTR src_ptr, dst_ptr;
+@@ -201,6 +339,8 @@
+    */
+   for (ci = 0; ci < dstinfo->num_components; ci++) {
+     compptr = dstinfo->comp_info + ci;
++    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
++    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+ 	 dst_blk_y += compptr->v_samp_factor) {
+       dst_buffer = (*srcinfo->mem->access_virt_barray)
+@@ -210,11 +350,12 @@
+ 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+ 	     dst_blk_x += compptr->h_samp_factor) {
+ 	  src_buffer = (*srcinfo->mem->access_virt_barray)
+-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
++	    ((j_common_ptr) srcinfo, src_coef_arrays[ci],
++	     dst_blk_x + x_crop_blocks,
+ 	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+ 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+-	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
+ 	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
++	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y + y_crop_blocks];
+ 	    for (i = 0; i < DCTSIZE; i++)
+ 	      for (j = 0; j < DCTSIZE; j++)
+ 		dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+@@ -228,6 +369,7 @@
+ 
+ LOCAL(void)
+ do_rot_90 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
++	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+ 	   jvirt_barray_ptr *src_coef_arrays,
+ 	   jvirt_barray_ptr *dst_coef_arrays)
+ /* 90 degree rotation is equivalent to
+@@ -237,6 +379,7 @@
+  */
+ {
+   JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;
++  JDIMENSION x_crop_blocks, y_crop_blocks;
+   int ci, i, j, offset_x, offset_y;
+   JBLOCKARRAY src_buffer, dst_buffer;
+   JCOEFPTR src_ptr, dst_ptr;
+@@ -246,11 +389,13 @@
+    * at the (output) right edge properly.  They just get transposed and
+    * not mirrored.
+    */
+-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
++  MCU_cols = srcinfo->image_height / (dstinfo->max_h_samp_factor * DCTSIZE);
+ 
+   for (ci = 0; ci < dstinfo->num_components; ci++) {
+     compptr = dstinfo->comp_info + ci;
+     comp_width = MCU_cols * compptr->h_samp_factor;
++    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
++    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+ 	 dst_blk_y += compptr->v_samp_factor) {
+       dst_buffer = (*srcinfo->mem->access_virt_barray)
+@@ -259,15 +404,26 @@
+       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+ 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+ 	     dst_blk_x += compptr->h_samp_factor) {
+-	  src_buffer = (*srcinfo->mem->access_virt_barray)
+-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
+-	     (JDIMENSION) compptr->h_samp_factor, FALSE);
++	  if (x_crop_blocks + dst_blk_x < comp_width) {
++	    /* Block is within the mirrorable area. */
++	    src_buffer = (*srcinfo->mem->access_virt_barray)
++	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
++	       comp_width - x_crop_blocks - dst_blk_x -
++	       (JDIMENSION) compptr->h_samp_factor,
++	       (JDIMENSION) compptr->h_samp_factor, FALSE);
++	  } else {
++	    /* Edge blocks are transposed but not mirrored. */
++	    src_buffer = (*srcinfo->mem->access_virt_barray)
++	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
++	       dst_blk_x + x_crop_blocks,
++	       (JDIMENSION) compptr->h_samp_factor, FALSE);
++	  }
+ 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+-	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
+-	    if (dst_blk_x < comp_width) {
++	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
++	    if (x_crop_blocks + dst_blk_x < comp_width) {
+ 	      /* Block is within the mirrorable area. */
+-	      dst_ptr = dst_buffer[offset_y]
+-		[comp_width - dst_blk_x - offset_x - 1];
++	      src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
++		[dst_blk_y + offset_y + y_crop_blocks];
+ 	      for (i = 0; i < DCTSIZE; i++) {
+ 		for (j = 0; j < DCTSIZE; j++)
+ 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+@@ -277,7 +433,8 @@
+ 	      }
+ 	    } else {
+ 	      /* Edge blocks are transposed but not mirrored. */
+-	      dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
++	      src_ptr = src_buffer[offset_x]
++		[dst_blk_y + offset_y + y_crop_blocks];
+ 	      for (i = 0; i < DCTSIZE; i++)
+ 		for (j = 0; j < DCTSIZE; j++)
+ 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+@@ -292,6 +449,7 @@
+ 
+ LOCAL(void)
+ do_rot_270 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
++	    JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+ 	    jvirt_barray_ptr *src_coef_arrays,
+ 	    jvirt_barray_ptr *dst_coef_arrays)
+ /* 270 degree rotation is equivalent to
+@@ -301,6 +459,7 @@
+  */
+ {
+   JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
++  JDIMENSION x_crop_blocks, y_crop_blocks;
+   int ci, i, j, offset_x, offset_y;
+   JBLOCKARRAY src_buffer, dst_buffer;
+   JCOEFPTR src_ptr, dst_ptr;
+@@ -310,11 +469,13 @@
+    * at the (output) bottom edge properly.  They just get transposed and
+    * not mirrored.
+    */
+-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
++  MCU_rows = srcinfo->image_width / (dstinfo->max_v_samp_factor * DCTSIZE);
+ 
+   for (ci = 0; ci < dstinfo->num_components; ci++) {
+     compptr = dstinfo->comp_info + ci;
+     comp_height = MCU_rows * compptr->v_samp_factor;
++    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
++    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+ 	 dst_blk_y += compptr->v_samp_factor) {
+       dst_buffer = (*srcinfo->mem->access_virt_barray)
+@@ -324,14 +485,15 @@
+ 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+ 	     dst_blk_x += compptr->h_samp_factor) {
+ 	  src_buffer = (*srcinfo->mem->access_virt_barray)
+-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
++	    ((j_common_ptr) srcinfo, src_coef_arrays[ci],
++	     dst_blk_x + x_crop_blocks,
+ 	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+ 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+ 	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+-	    if (dst_blk_y < comp_height) {
++	    if (y_crop_blocks + dst_blk_y < comp_height) {
+ 	      /* Block is within the mirrorable area. */
+ 	      src_ptr = src_buffer[offset_x]
+-		[comp_height - dst_blk_y - offset_y - 1];
++		[comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
+ 	      for (i = 0; i < DCTSIZE; i++) {
+ 		for (j = 0; j < DCTSIZE; j++) {
+ 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+@@ -341,7 +503,8 @@
+ 	      }
+ 	    } else {
+ 	      /* Edge blocks are transposed but not mirrored. */
+-	      src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
++	      src_ptr = src_buffer[offset_x]
++		[dst_blk_y + offset_y + y_crop_blocks];
+ 	      for (i = 0; i < DCTSIZE; i++)
+ 		for (j = 0; j < DCTSIZE; j++)
+ 		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+@@ -356,6 +519,7 @@
+ 
+ LOCAL(void)
+ do_rot_180 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
++	    JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+ 	    jvirt_barray_ptr *src_coef_arrays,
+ 	    jvirt_barray_ptr *dst_coef_arrays)
+ /* 180 degree rotation is equivalent to
+@@ -365,89 +529,93 @@
+  */
+ {
+   JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
++  JDIMENSION x_crop_blocks, y_crop_blocks;
+   int ci, i, j, offset_y;
+   JBLOCKARRAY src_buffer, dst_buffer;
+   JBLOCKROW src_row_ptr, dst_row_ptr;
+   JCOEFPTR src_ptr, dst_ptr;
+   jpeg_component_info *compptr;
+ 
+-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
++  MCU_cols = srcinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
++  MCU_rows = srcinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+ 
+   for (ci = 0; ci < dstinfo->num_components; ci++) {
+     compptr = dstinfo->comp_info + ci;
+     comp_width = MCU_cols * compptr->h_samp_factor;
+     comp_height = MCU_rows * compptr->v_samp_factor;
++    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
++    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+ 	 dst_blk_y += compptr->v_samp_factor) {
+       dst_buffer = (*srcinfo->mem->access_virt_barray)
+ 	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+ 	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+-      if (dst_blk_y < comp_height) {
++      if (y_crop_blocks + dst_blk_y < comp_height) {
+ 	/* Row is within the vertically mirrorable area. */
+ 	src_buffer = (*srcinfo->mem->access_virt_barray)
+ 	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+-	   comp_height - dst_blk_y - (JDIMENSION) compptr->v_samp_factor,
++	   comp_height - y_crop_blocks - dst_blk_y -
++	   (JDIMENSION) compptr->v_samp_factor,
+ 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+       } else {
+ 	/* Bottom-edge rows are only mirrored horizontally. */
+ 	src_buffer = (*srcinfo->mem->access_virt_barray)
+-	  ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_y,
++	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
++	   dst_blk_y + y_crop_blocks,
+ 	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+       }
+       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+-	if (dst_blk_y < comp_height) {
++	dst_row_ptr = dst_buffer[offset_y];
++	if (y_crop_blocks + dst_blk_y < comp_height) {
+ 	  /* Row is within the mirrorable area. */
+-	  dst_row_ptr = dst_buffer[offset_y];
+ 	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
+-	  /* Process the blocks that can be mirrored both ways. */
+-	  for (dst_blk_x = 0; dst_blk_x < comp_width; dst_blk_x++) {
++	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+ 	    dst_ptr = dst_row_ptr[dst_blk_x];
+-	    src_ptr = src_row_ptr[comp_width - dst_blk_x - 1];
+-	    for (i = 0; i < DCTSIZE; i += 2) {
+-	      /* For even row, negate every odd column. */
+-	      for (j = 0; j < DCTSIZE; j += 2) {
+-		*dst_ptr++ = *src_ptr++;
+-		*dst_ptr++ = - *src_ptr++;
++	    if (x_crop_blocks + dst_blk_x < comp_width) {
++	      /* Process the blocks that can be mirrored both ways. */
++	      src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
++	      for (i = 0; i < DCTSIZE; i += 2) {
++		/* For even row, negate every odd column. */
++		for (j = 0; j < DCTSIZE; j += 2) {
++		  *dst_ptr++ = *src_ptr++;
++		  *dst_ptr++ = - *src_ptr++;
++		}
++		/* For odd row, negate every even column. */
++		for (j = 0; j < DCTSIZE; j += 2) {
++		  *dst_ptr++ = - *src_ptr++;
++		  *dst_ptr++ = *src_ptr++;
++		}
+ 	      }
+-	      /* For odd row, negate every even column. */
+-	      for (j = 0; j < DCTSIZE; j += 2) {
+-		*dst_ptr++ = - *src_ptr++;
+-		*dst_ptr++ = *src_ptr++;
++	    } else {
++	      /* Any remaining right-edge blocks are only mirrored vertically. */
++	      src_ptr = src_row_ptr[x_crop_blocks + dst_blk_x];
++	      for (i = 0; i < DCTSIZE; i += 2) {
++		for (j = 0; j < DCTSIZE; j++)
++		  *dst_ptr++ = *src_ptr++;
++		for (j = 0; j < DCTSIZE; j++)
++		  *dst_ptr++ = - *src_ptr++;
+ 	      }
+ 	    }
+ 	  }
+-	  /* Any remaining right-edge blocks are only mirrored vertically. */
+-	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+-	    dst_ptr = dst_row_ptr[dst_blk_x];
+-	    src_ptr = src_row_ptr[dst_blk_x];
+-	    for (i = 0; i < DCTSIZE; i += 2) {
+-	      for (j = 0; j < DCTSIZE; j++)
+-		*dst_ptr++ = *src_ptr++;
+-	      for (j = 0; j < DCTSIZE; j++)
+-		*dst_ptr++ = - *src_ptr++;
+-	    }
+-	  }
+ 	} else {
+ 	  /* Remaining rows are just mirrored horizontally. */
+-	  dst_row_ptr = dst_buffer[offset_y];
+ 	  src_row_ptr = src_buffer[offset_y];
+-	  /* Process the blocks that can be mirrored. */
+-	  for (dst_blk_x = 0; dst_blk_x < comp_width; dst_blk_x++) {
+-	    dst_ptr = dst_row_ptr[dst_blk_x];
+-	    src_ptr = src_row_ptr[comp_width - dst_blk_x - 1];
+-	    for (i = 0; i < DCTSIZE2; i += 2) {
+-	      *dst_ptr++ = *src_ptr++;
+-	      *dst_ptr++ = - *src_ptr++;
++	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
++	    if (x_crop_blocks + dst_blk_x < comp_width) {
++	      /* Process the blocks that can be mirrored. */
++	      dst_ptr = dst_row_ptr[dst_blk_x];
++	      src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
++	      for (i = 0; i < DCTSIZE2; i += 2) {
++		*dst_ptr++ = *src_ptr++;
++		*dst_ptr++ = - *src_ptr++;
++	      }
++	    } else {
++	      /* Any remaining right-edge blocks are only copied. */
++	      jcopy_block_row(src_row_ptr + dst_blk_x + x_crop_blocks,
++			      dst_row_ptr + dst_blk_x,
++			      (JDIMENSION) 1);
+ 	    }
+ 	  }
+-	  /* Any remaining right-edge blocks are only copied. */
+-	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+-	    dst_ptr = dst_row_ptr[dst_blk_x];
+-	    src_ptr = src_row_ptr[dst_blk_x];
+-	    for (i = 0; i < DCTSIZE2; i++)
+-	      *dst_ptr++ = *src_ptr++;
+-	  }
+ 	}
+       }
+     }
+@@ -457,6 +625,7 @@
+ 
+ LOCAL(void)
+ do_transverse (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
++	       JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+ 	       jvirt_barray_ptr *src_coef_arrays,
+ 	       jvirt_barray_ptr *dst_coef_arrays)
+ /* Transverse transpose is equivalent to
+@@ -470,18 +639,21 @@
+  */
+ {
+   JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
++  JDIMENSION x_crop_blocks, y_crop_blocks;
+   int ci, i, j, offset_x, offset_y;
+   JBLOCKARRAY src_buffer, dst_buffer;
+   JCOEFPTR src_ptr, dst_ptr;
+   jpeg_component_info *compptr;
+ 
+-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
++  MCU_cols = srcinfo->image_height / (dstinfo->max_h_samp_factor * DCTSIZE);
++  MCU_rows = srcinfo->image_width / (dstinfo->max_v_samp_factor * DCTSIZE);
+ 
+   for (ci = 0; ci < dstinfo->num_components; ci++) {
+     compptr = dstinfo->comp_info + ci;
+     comp_width = MCU_cols * compptr->h_samp_factor;
+     comp_height = MCU_rows * compptr->v_samp_factor;
++    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
++    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+     for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+ 	 dst_blk_y += compptr->v_samp_factor) {
+       dst_buffer = (*srcinfo->mem->access_virt_barray)
+@@ -490,17 +662,26 @@
+       for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+ 	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+ 	     dst_blk_x += compptr->h_samp_factor) {
+-	  src_buffer = (*srcinfo->mem->access_virt_barray)
+-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
+-	     (JDIMENSION) compptr->h_samp_factor, FALSE);
++	  if (x_crop_blocks + dst_blk_x < comp_width) {
++	    /* Block is within the mirrorable area. */
++	    src_buffer = (*srcinfo->mem->access_virt_barray)
++	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
++	       comp_width - x_crop_blocks - dst_blk_x -
++	       (JDIMENSION) compptr->h_samp_factor,
++	       (JDIMENSION) compptr->h_samp_factor, FALSE);
++	  } else {
++	    src_buffer = (*srcinfo->mem->access_virt_barray)
++	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
++	       dst_blk_x + x_crop_blocks,
++	       (JDIMENSION) compptr->h_samp_factor, FALSE);
++	  }
+ 	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+-	    if (dst_blk_y < comp_height) {
+-	      src_ptr = src_buffer[offset_x]
+-		[comp_height - dst_blk_y - offset_y - 1];
+-	      if (dst_blk_x < comp_width) {
++	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
++	    if (y_crop_blocks + dst_blk_y < comp_height) {
++	      if (x_crop_blocks + dst_blk_x < comp_width) {
+ 		/* Block is within the mirrorable area. */
+-		dst_ptr = dst_buffer[offset_y]
+-		  [comp_width - dst_blk_x - offset_x - 1];
++		src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
++		  [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
+ 		for (i = 0; i < DCTSIZE; i++) {
+ 		  for (j = 0; j < DCTSIZE; j++) {
+ 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+@@ -516,7 +697,8 @@
+ 		}
+ 	      } else {
+ 		/* Right-edge blocks are mirrored in y only */
+-		dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
++		src_ptr = src_buffer[offset_x]
++		  [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
+ 		for (i = 0; i < DCTSIZE; i++) {
+ 		  for (j = 0; j < DCTSIZE; j++) {
+ 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+@@ -526,11 +708,10 @@
+ 		}
+ 	      }
+ 	    } else {
+-	      src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
+-	      if (dst_blk_x < comp_width) {
++	      if (x_crop_blocks + dst_blk_x < comp_width) {
+ 		/* Bottom-edge blocks are mirrored in x only */
+-		dst_ptr = dst_buffer[offset_y]
+-		  [comp_width - dst_blk_x - offset_x - 1];
++		src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
++		  [dst_blk_y + offset_y + y_crop_blocks];
+ 		for (i = 0; i < DCTSIZE; i++) {
+ 		  for (j = 0; j < DCTSIZE; j++)
+ 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+@@ -540,7 +721,8 @@
+ 		}
+ 	      } else {
+ 		/* At lower right corner, just transpose, no mirroring */
+-		dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
++		src_ptr = src_buffer[offset_x]
++		  [dst_blk_y + offset_y + y_crop_blocks];
+ 		for (i = 0; i < DCTSIZE; i++)
+ 		  for (j = 0; j < DCTSIZE; j++)
+ 		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+@@ -554,8 +736,116 @@
+ }
+ 
+ 
++/* Parse an unsigned integer: subroutine for jtransform_parse_crop_spec.
++ * Returns TRUE if valid integer found, FALSE if not.
++ * *strptr is advanced over the digit string, and *result is set to its value.
++ */
++
++LOCAL(boolean)
++jt_read_integer (const char ** strptr, JDIMENSION * result)
++{
++  const char * ptr = *strptr;
++  JDIMENSION val = 0;
++
++  for (; isdigit(*ptr); ptr++) {
++    val = val * 10 + (JDIMENSION) (*ptr - '0');
++  }
++  *result = val;
++  if (ptr == *strptr)
++    return FALSE;		/* oops, no digits */
++  *strptr = ptr;
++  return TRUE;
++}
++
++
++/* Parse a crop specification (written in X11 geometry style).
++ * The routine returns TRUE if the spec string is valid, FALSE if not.
++ *
++ * The crop spec string should have the format
++ *	<width>x<height>{+-}<xoffset>{+-}<yoffset>
++ * where width, height, xoffset, and yoffset are unsigned integers.
++ * Each of the elements can be omitted to indicate a default value.
++ * (A weakness of this style is that it is not possible to omit xoffset
++ * while specifying yoffset, since they look alike.)
++ *
++ * This code is loosely based on XParseGeometry from the X11 distribution.
++ */
++
++GLOBAL(boolean)
++jtransform_parse_crop_spec (jpeg_transform_info *info, const char *spec)
++{
++  info->crop = FALSE;
++  info->crop_width_set = JCROP_UNSET;
++  info->crop_height_set = JCROP_UNSET;
++  info->crop_xoffset_set = JCROP_UNSET;
++  info->crop_yoffset_set = JCROP_UNSET;
++
++  if (isdigit(*spec)) {
++    /* fetch width */
++    if (! jt_read_integer(&spec, &info->crop_width))
++      return FALSE;
++    info->crop_width_set = JCROP_POS;
++  }
++  if (*spec == 'x' || *spec == 'X') {	
++    /* fetch height */
++    spec++;
++    if (! jt_read_integer(&spec, &info->crop_height))
++      return FALSE;
++    info->crop_height_set = JCROP_POS;
++  }
++  if (*spec == '+' || *spec == '-') {
++    /* fetch xoffset */
++    info->crop_xoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;
++    spec++;
++    if (! jt_read_integer(&spec, &info->crop_xoffset))
++      return FALSE;
++  }
++  if (*spec == '+' || *spec == '-') {
++    /* fetch yoffset */
++    info->crop_yoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;
++    spec++;
++    if (! jt_read_integer(&spec, &info->crop_yoffset))
++      return FALSE;
++  }
++  /* We had better have gotten to the end of the string. */
++  if (*spec != '\0')
++    return FALSE;
++  info->crop = TRUE;
++  return TRUE;
++}
++
++
++/* Trim off any partial iMCUs on the indicated destination edge */
++
++LOCAL(void)
++trim_right_edge (jpeg_transform_info *info, JDIMENSION full_width)
++{
++  JDIMENSION MCU_cols;
++
++  MCU_cols = info->output_width / (info->max_h_samp_factor * DCTSIZE);
++  if (MCU_cols > 0 && info->x_crop_offset + MCU_cols ==
++      full_width / (info->max_h_samp_factor * DCTSIZE))
++    info->output_width = MCU_cols * (info->max_h_samp_factor * DCTSIZE);
++}
++
++LOCAL(void)
++trim_bottom_edge (jpeg_transform_info *info, JDIMENSION full_height)
++{
++  JDIMENSION MCU_rows;
++
++  MCU_rows = info->output_height / (info->max_v_samp_factor * DCTSIZE);
++  if (MCU_rows > 0 && info->y_crop_offset + MCU_rows ==
++      full_height / (info->max_v_samp_factor * DCTSIZE))
++    info->output_height = MCU_rows * (info->max_v_samp_factor * DCTSIZE);
++}
++
++
+ /* Request any required workspace.
+  *
++ * This routine figures out the size that the output image will be
++ * (which implies that all the transform parameters must be set before
++ * it is called).
++ *
+  * We allocate the workspace virtual arrays from the source decompression
+  * object, so that all the arrays (both the original data and the workspace)
+  * will be taken into account while making memory management decisions.
+@@ -569,9 +859,13 @@
+ 			      jpeg_transform_info *info)
+ {
+   jvirt_barray_ptr *coef_arrays = NULL;
++  boolean need_workspace, transpose_it;
+   jpeg_component_info *compptr;
+-  int ci;
++  JDIMENSION xoffset, yoffset, width_in_iMCUs, height_in_iMCUs;
++  JDIMENSION width_in_blocks, height_in_blocks;
++  int ci, h_samp_factor, v_samp_factor;
+ 
++  /* Determine number of components in output image */
+   if (info->force_grayscale &&
+       srcinfo->jpeg_color_space == JCS_YCbCr &&
+       srcinfo->num_components == 3) {
+@@ -581,55 +875,181 @@
+     /* Process all the components */
+     info->num_components = srcinfo->num_components;
+   }
++  /* If there is only one output component, force the iMCU size to be 1;
++   * else use the source iMCU size.  (This allows us to do the right thing
++   * when reducing color to grayscale, and also provides a handy way of
++   * cleaning up "funny" grayscale images whose sampling factors are not 1x1.)
++   */
+ 
+   switch (info->transform) {
++  case JXFORM_TRANSPOSE:
++  case JXFORM_TRANSVERSE:
++  case JXFORM_ROT_90:
++  case JXFORM_ROT_270:
++    info->output_width = srcinfo->image_height;
++    info->output_height = srcinfo->image_width;
++    if (info->num_components == 1) {
++      info->max_h_samp_factor = 1;
++      info->max_v_samp_factor = 1;
++    } else {
++      info->max_h_samp_factor = srcinfo->max_v_samp_factor;
++      info->max_v_samp_factor = srcinfo->max_h_samp_factor;
++    }
++    break;
++  default:
++    info->output_width = srcinfo->image_width;
++    info->output_height = srcinfo->image_height;
++    if (info->num_components == 1) {
++      info->max_h_samp_factor = 1;
++      info->max_v_samp_factor = 1;
++    } else {
++      info->max_h_samp_factor = srcinfo->max_h_samp_factor;
++      info->max_v_samp_factor = srcinfo->max_v_samp_factor;
++    }
++    break;
++  }
++
++  /* If cropping has been requested, compute the crop area's position and
++   * dimensions, ensuring that its upper left corner falls at an iMCU boundary.
++   */
++  if (info->crop) {
++    /* Insert default values for unset crop parameters */
++    if (info->crop_xoffset_set == JCROP_UNSET)
++      info->crop_xoffset = 0;	/* default to +0 */
++    if (info->crop_yoffset_set == JCROP_UNSET)
++      info->crop_yoffset = 0;	/* default to +0 */
++    if (info->crop_xoffset >= info->output_width ||
++	info->crop_yoffset >= info->output_height)
++      ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);
++    if (info->crop_width_set == JCROP_UNSET)
++      info->crop_width = info->output_width - info->crop_xoffset;
++    if (info->crop_height_set == JCROP_UNSET)
++      info->crop_height = info->output_height - info->crop_yoffset;
++    /* Ensure parameters are valid */
++    if (info->crop_width <= 0 || info->crop_width > info->output_width ||
++	info->crop_height <= 0 || info->crop_height > info->output_height ||
++	info->crop_xoffset > info->output_width - info->crop_width ||
++	info->crop_yoffset > info->output_height - info->crop_height)
++      ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);
++    /* Convert negative crop offsets into regular offsets */
++    if (info->crop_xoffset_set == JCROP_NEG)
++      xoffset = info->output_width - info->crop_width - info->crop_xoffset;
++    else
++      xoffset = info->crop_xoffset;
++    if (info->crop_yoffset_set == JCROP_NEG)
++      yoffset = info->output_height - info->crop_height - info->crop_yoffset;
++    else
++      yoffset = info->crop_yoffset;
++    /* Now adjust so that upper left corner falls at an iMCU boundary */
++    info->output_width =
++      info->crop_width + (xoffset % (info->max_h_samp_factor * DCTSIZE));
++    info->output_height =
++      info->crop_height + (yoffset % (info->max_v_samp_factor * DCTSIZE));
++    /* Save x/y offsets measured in iMCUs */
++    info->x_crop_offset = xoffset / (info->max_h_samp_factor * DCTSIZE);
++    info->y_crop_offset = yoffset / (info->max_v_samp_factor * DCTSIZE);
++  } else {
++    info->x_crop_offset = 0;
++    info->y_crop_offset = 0;
++  }
++
++  /* Figure out whether we need workspace arrays,
++   * and if so whether they are transposed relative to the source.
++   */
++  need_workspace = FALSE;
++  transpose_it = FALSE;
++  switch (info->transform) {
+   case JXFORM_NONE:
++    if (info->x_crop_offset != 0 || info->y_crop_offset != 0)
++      need_workspace = TRUE;
++    /* No workspace needed if neither cropping nor transforming */
++    break;
+   case JXFORM_FLIP_H:
+-    /* Don't need a workspace array */
++    if (info->trim)
++      trim_right_edge(info, srcinfo->image_width);
++    if (info->y_crop_offset != 0)
++      need_workspace = TRUE;
++    /* do_flip_h_no_crop doesn't need a workspace array */
+     break;
+   case JXFORM_FLIP_V:
+-  case JXFORM_ROT_180:
+-    /* Need workspace arrays having same dimensions as source image.
+-     * Note that we allocate arrays padded out to the next iMCU boundary,
+-     * so that transform routines need not worry about missing edge blocks.
+-     */
+-    coef_arrays = (jvirt_barray_ptr *)
+-      (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
+-	SIZEOF(jvirt_barray_ptr) * info->num_components);
+-    for (ci = 0; ci < info->num_components; ci++) {
+-      compptr = srcinfo->comp_info + ci;
+-      coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
+-	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
+-	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
+-				(long) compptr->h_samp_factor),
+-	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
+-				(long) compptr->v_samp_factor),
+-	 (JDIMENSION) compptr->v_samp_factor);
+-    }
++    if (info->trim)
++      trim_bottom_edge(info, srcinfo->image_height);
++    /* Need workspace arrays having same dimensions as source image. */
++    need_workspace = TRUE;
+     break;
+   case JXFORM_TRANSPOSE:
++    /* transpose does NOT have to trim anything */
++    /* Need workspace arrays having transposed dimensions. */
++    need_workspace = TRUE;
++    transpose_it = TRUE;
++    break;
+   case JXFORM_TRANSVERSE:
++    if (info->trim) {
++      trim_right_edge(info, srcinfo->image_height);
++      trim_bottom_edge(info, srcinfo->image_width);
++    }
++    /* Need workspace arrays having transposed dimensions. */
++    need_workspace = TRUE;
++    transpose_it = TRUE;
++    break;
+   case JXFORM_ROT_90:
++    if (info->trim)
++      trim_right_edge(info, srcinfo->image_height);
++    /* Need workspace arrays having transposed dimensions. */
++    need_workspace = TRUE;
++    transpose_it = TRUE;
++    break;
++  case JXFORM_ROT_180:
++    if (info->trim) {
++      trim_right_edge(info, srcinfo->image_width);
++      trim_bottom_edge(info, srcinfo->image_height);
++    }
++    /* Need workspace arrays having same dimensions as source image. */
++    need_workspace = TRUE;
++    break;
+   case JXFORM_ROT_270:
+-    /* Need workspace arrays having transposed dimensions.
+-     * Note that we allocate arrays padded out to the next iMCU boundary,
+-     * so that transform routines need not worry about missing edge blocks.
+-     */
++    if (info->trim)
++      trim_bottom_edge(info, srcinfo->image_width);
++    /* Need workspace arrays having transposed dimensions. */
++    need_workspace = TRUE;
++    transpose_it = TRUE;
++    break;
++  }
++
++  /* Allocate workspace if needed.
++   * Note that we allocate arrays padded out to the next iMCU boundary,
++   * so that transform routines need not worry about missing edge blocks.
++   */
++  if (need_workspace) {
+     coef_arrays = (jvirt_barray_ptr *)
+       (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
+-	SIZEOF(jvirt_barray_ptr) * info->num_components);
++		SIZEOF(jvirt_barray_ptr) * info->num_components);
++    width_in_iMCUs = (JDIMENSION)
++      jdiv_round_up((long) info->output_width,
++		    (long) (info->max_h_samp_factor * DCTSIZE));
++    height_in_iMCUs = (JDIMENSION)
++      jdiv_round_up((long) info->output_height,
++		    (long) (info->max_v_samp_factor * DCTSIZE));
+     for (ci = 0; ci < info->num_components; ci++) {
+       compptr = srcinfo->comp_info + ci;
++      if (info->num_components == 1) {
++	/* we're going to force samp factors to 1x1 in this case */
++	h_samp_factor = v_samp_factor = 1;
++      } else if (transpose_it) {
++	h_samp_factor = compptr->v_samp_factor;
++	v_samp_factor = compptr->h_samp_factor;
++      } else {
++	h_samp_factor = compptr->h_samp_factor;
++	v_samp_factor = compptr->v_samp_factor;
++      }
++      width_in_blocks = width_in_iMCUs * h_samp_factor;
++      height_in_blocks = height_in_iMCUs * v_samp_factor;
+       coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
+ 	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
+-	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
+-				(long) compptr->v_samp_factor),
+-	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
+-				(long) compptr->h_samp_factor),
+-	 (JDIMENSION) compptr->h_samp_factor);
++	 width_in_blocks, height_in_blocks, (JDIMENSION) v_samp_factor);
+     }
+-    break;
+   }
++
+   info->workspace_coef_arrays = coef_arrays;
+ }
+ 
+@@ -642,14 +1062,8 @@
+   int tblno, i, j, ci, itemp;
+   jpeg_component_info *compptr;
+   JQUANT_TBL *qtblptr;
+-  JDIMENSION dtemp;
+   UINT16 qtemp;
+ 
+-  /* Transpose basic image dimensions */
+-  dtemp = dstinfo->image_width;
+-  dstinfo->image_width = dstinfo->image_height;
+-  dstinfo->image_height = dtemp;
+-
+   /* Transpose sampling factors */
+   for (ci = 0; ci < dstinfo->num_components; ci++) {
+     compptr = dstinfo->comp_info + ci;
+@@ -674,46 +1088,159 @@
+ }
+ 
+ 
+-/* Trim off any partial iMCUs on the indicated destination edge */
++/* Adjust Exif image parameters.
++ *
++ * We try to adjust the Tags ExifImageWidth and ExifImageHeight if possible.
++ */
+ 
+ LOCAL(void)
+-trim_right_edge (j_compress_ptr dstinfo)
++adjust_exif_parameters (JOCTET FAR * data, unsigned int length,
++			JDIMENSION new_width, JDIMENSION new_height)
+ {
+-  int ci, max_h_samp_factor;
+-  JDIMENSION MCU_cols;
++  boolean is_motorola; /* Flag for byte order */
++  unsigned int number_of_tags, tagnum;
++  unsigned int firstoffset, offset;
++  JDIMENSION new_value;
+ 
+-  /* We have to compute max_h_samp_factor ourselves,
+-   * because it hasn't been set yet in the destination
+-   * (and we don't want to use the source's value).
+-   */
+-  max_h_samp_factor = 1;
+-  for (ci = 0; ci < dstinfo->num_components; ci++) {
+-    int h_samp_factor = dstinfo->comp_info[ci].h_samp_factor;
+-    max_h_samp_factor = MAX(max_h_samp_factor, h_samp_factor);
++  if (length < 12) return; /* Length of an IFD entry */
++
++  /* Discover byte order */
++  if (GETJOCTET(data[0]) == 0x49 && GETJOCTET(data[1]) == 0x49)
++    is_motorola = FALSE;
++  else if (GETJOCTET(data[0]) == 0x4D && GETJOCTET(data[1]) == 0x4D)
++    is_motorola = TRUE;
++  else
++    return;
++
++  /* Check Tag Mark */
++  if (is_motorola) {
++    if (GETJOCTET(data[2]) != 0) return;
++    if (GETJOCTET(data[3]) != 0x2A) return;
++  } else {
++    if (GETJOCTET(data[3]) != 0) return;
++    if (GETJOCTET(data[2]) != 0x2A) return;
+   }
+-  MCU_cols = dstinfo->image_width / (max_h_samp_factor * DCTSIZE);
+-  if (MCU_cols > 0)		/* can't trim to 0 pixels */
+-    dstinfo->image_width = MCU_cols * (max_h_samp_factor * DCTSIZE);
+-}
+ 
+-LOCAL(void)
+-trim_bottom_edge (j_compress_ptr dstinfo)
+-{
+-  int ci, max_v_samp_factor;
+-  JDIMENSION MCU_rows;
++  /* Get first IFD offset (offset to IFD0) */
++  if (is_motorola) {
++    if (GETJOCTET(data[4]) != 0) return;
++    if (GETJOCTET(data[5]) != 0) return;
++    firstoffset = GETJOCTET(data[6]);
++    firstoffset <<= 8;
++    firstoffset += GETJOCTET(data[7]);
++  } else {
++    if (GETJOCTET(data[7]) != 0) return;
++    if (GETJOCTET(data[6]) != 0) return;
++    firstoffset = GETJOCTET(data[5]);
++    firstoffset <<= 8;
++    firstoffset += GETJOCTET(data[4]);
++  }
++  if (firstoffset > length - 2) return; /* check end of data segment */
+ 
+-  /* We have to compute max_v_samp_factor ourselves,
+-   * because it hasn't been set yet in the destination
+-   * (and we don't want to use the source's value).
+-   */
+-  max_v_samp_factor = 1;
+-  for (ci = 0; ci < dstinfo->num_components; ci++) {
+-    int v_samp_factor = dstinfo->comp_info[ci].v_samp_factor;
+-    max_v_samp_factor = MAX(max_v_samp_factor, v_samp_factor);
++  /* Get the number of directory entries contained in this IFD */
++  if (is_motorola) {
++    number_of_tags = GETJOCTET(data[firstoffset]);
++    number_of_tags <<= 8;
++    number_of_tags += GETJOCTET(data[firstoffset+1]);
++  } else {
++    number_of_tags = GETJOCTET(data[firstoffset+1]);
++    number_of_tags <<= 8;
++    number_of_tags += GETJOCTET(data[firstoffset]);
+   }
+-  MCU_rows = dstinfo->image_height / (max_v_samp_factor * DCTSIZE);
+-  if (MCU_rows > 0)		/* can't trim to 0 pixels */
+-    dstinfo->image_height = MCU_rows * (max_v_samp_factor * DCTSIZE);
++  if (number_of_tags == 0) return;
++  firstoffset += 2;
++
++  /* Search for ExifSubIFD offset Tag in IFD0 */
++  for (;;) {
++    if (firstoffset > length - 12) return; /* check end of data segment */
++    /* Get Tag number */
++    if (is_motorola) {
++      tagnum = GETJOCTET(data[firstoffset]);
++      tagnum <<= 8;
++      tagnum += GETJOCTET(data[firstoffset+1]);
++    } else {
++      tagnum = GETJOCTET(data[firstoffset+1]);
++      tagnum <<= 8;
++      tagnum += GETJOCTET(data[firstoffset]);
++    }
++    if (tagnum == 0x8769) break; /* found ExifSubIFD offset Tag */
++    if (--number_of_tags == 0) return;
++    firstoffset += 12;
++  }
++
++  /* Get the ExifSubIFD offset */
++  if (is_motorola) {
++    if (GETJOCTET(data[firstoffset+8]) != 0) return;
++    if (GETJOCTET(data[firstoffset+9]) != 0) return;
++    offset = GETJOCTET(data[firstoffset+10]);
++    offset <<= 8;
++    offset += GETJOCTET(data[firstoffset+11]);
++  } else {
++    if (GETJOCTET(data[firstoffset+11]) != 0) return;
++    if (GETJOCTET(data[firstoffset+10]) != 0) return;
++    offset = GETJOCTET(data[firstoffset+9]);
++    offset <<= 8;
++    offset += GETJOCTET(data[firstoffset+8]);
++  }
++  if (offset > length - 2) return; /* check end of data segment */
++
++  /* Get the number of directory entries contained in this SubIFD */
++  if (is_motorola) {
++    number_of_tags = GETJOCTET(data[offset]);
++    number_of_tags <<= 8;
++    number_of_tags += GETJOCTET(data[offset+1]);
++  } else {
++    number_of_tags = GETJOCTET(data[offset+1]);
++    number_of_tags <<= 8;
++    number_of_tags += GETJOCTET(data[offset]);
++  }
++  if (number_of_tags < 2) return;
++  offset += 2;
++
++  /* Search for ExifImageWidth and ExifImageHeight Tags in this SubIFD */
++  do {
++    if (offset > length - 12) return; /* check end of data segment */
++    /* Get Tag number */
++    if (is_motorola) {
++      tagnum = GETJOCTET(data[offset]);
++      tagnum <<= 8;
++      tagnum += GETJOCTET(data[offset+1]);
++    } else {
++      tagnum = GETJOCTET(data[offset+1]);
++      tagnum <<= 8;
++      tagnum += GETJOCTET(data[offset]);
++    }
++    if (tagnum == 0xA002 || tagnum == 0xA003) {
++      if (tagnum == 0xA002)
++	new_value = new_width; /* ExifImageWidth Tag */
++      else
++	new_value = new_height; /* ExifImageHeight Tag */
++      if (is_motorola) {
++	data[offset+2] = 0; /* Format = unsigned long (4 octets) */
++	data[offset+3] = 4;
++	data[offset+4] = 0; /* Number Of Components = 1 */
++	data[offset+5] = 0;
++	data[offset+6] = 0;
++	data[offset+7] = 1;
++	data[offset+8] = 0;
++	data[offset+9] = 0;
++	data[offset+10] = (JOCTET)((new_value >> 8) & 0xFF);
++	data[offset+11] = (JOCTET)(new_value & 0xFF);
++      } else {
++	data[offset+2] = 4; /* Format = unsigned long (4 octets) */
++	data[offset+3] = 0;
++	data[offset+4] = 1; /* Number Of Components = 1 */
++	data[offset+5] = 0;
++	data[offset+6] = 0;
++	data[offset+7] = 0;
++	data[offset+8] = (JOCTET)(new_value & 0xFF);
++	data[offset+9] = (JOCTET)((new_value >> 8) & 0xFF);
++	data[offset+10] = 0;
++	data[offset+11] = 0;
++      }
++    }
++    offset += 12;
++  } while (--number_of_tags);
+ }
+ 
+ 
+@@ -736,18 +1263,22 @@
+ {
+   /* If force-to-grayscale is requested, adjust destination parameters */
+   if (info->force_grayscale) {
+-    /* We use jpeg_set_colorspace to make sure subsidiary settings get fixed
+-     * properly.  Among other things, the target h_samp_factor & v_samp_factor
+-     * will get set to 1, which typically won't match the source.
+-     * In fact we do this even if the source is already grayscale; that
+-     * provides an easy way of coercing a grayscale JPEG with funny sampling
+-     * factors to the customary 1,1.  (Some decoders fail on other factors.)
++    /* First, ensure we have YCbCr or grayscale data, and that the source's
++     * Y channel is full resolution.  (No reasonable person would make Y
++     * be less than full resolution, so actually coping with that case
++     * isn't worth extra code space.  But we check it to avoid crashing.)
+      */
+-    if ((dstinfo->jpeg_color_space == JCS_YCbCr &&
+-	 dstinfo->num_components == 3) ||
+-	(dstinfo->jpeg_color_space == JCS_GRAYSCALE &&
+-	 dstinfo->num_components == 1)) {
+-      /* We have to preserve the source's quantization table number. */
++    if (((dstinfo->jpeg_color_space == JCS_YCbCr &&
++	  dstinfo->num_components == 3) ||
++	 (dstinfo->jpeg_color_space == JCS_GRAYSCALE &&
++	  dstinfo->num_components == 1)) &&
++	srcinfo->comp_info[0].h_samp_factor == srcinfo->max_h_samp_factor &&
++	srcinfo->comp_info[0].v_samp_factor == srcinfo->max_v_samp_factor) {
++      /* We use jpeg_set_colorspace to make sure subsidiary settings get fixed
++       * properly.  Among other things, it sets the target h_samp_factor &
++       * v_samp_factor to 1, which typically won't match the source.
++       * We have to preserve the source's quantization table number, however.
++       */
+       int sv_quant_tbl_no = dstinfo->comp_info[0].quant_tbl_no;
+       jpeg_set_colorspace(dstinfo, JCS_GRAYSCALE);
+       dstinfo->comp_info[0].quant_tbl_no = sv_quant_tbl_no;
+@@ -755,50 +1286,52 @@
+       /* Sorry, can't do it */
+       ERREXIT(dstinfo, JERR_CONVERSION_NOTIMPL);
+     }
++  } else if (info->num_components == 1) {
++    /* For a single-component source, we force the destination sampling factors
++     * to 1x1, with or without force_grayscale.  This is useful because some
++     * decoders choke on grayscale images with other sampling factors.
++     */
++    dstinfo->comp_info[0].h_samp_factor = 1;
++    dstinfo->comp_info[0].v_samp_factor = 1;
+   }
+ 
+-  /* Correct the destination's image dimensions etc if necessary */
++  /* Correct the destination's image dimensions as necessary
++   * for crop and rotate/flip operations.
++   */
++  dstinfo->image_width = info->output_width;
++  dstinfo->image_height = info->output_height;
++
++  /* Transpose destination image parameters */
+   switch (info->transform) {
+-  case JXFORM_NONE:
+-    /* Nothing to do */
+-    break;
+-  case JXFORM_FLIP_H:
+-    if (info->trim)
+-      trim_right_edge(dstinfo);
+-    break;
+-  case JXFORM_FLIP_V:
+-    if (info->trim)
+-      trim_bottom_edge(dstinfo);
+-    break;
+   case JXFORM_TRANSPOSE:
+-    transpose_critical_parameters(dstinfo);
+-    /* transpose does NOT have to trim anything */
+-    break;
+   case JXFORM_TRANSVERSE:
+-    transpose_critical_parameters(dstinfo);
+-    if (info->trim) {
+-      trim_right_edge(dstinfo);
+-      trim_bottom_edge(dstinfo);
+-    }
+-    break;
+   case JXFORM_ROT_90:
+-    transpose_critical_parameters(dstinfo);
+-    if (info->trim)
+-      trim_right_edge(dstinfo);
+-    break;
+-  case JXFORM_ROT_180:
+-    if (info->trim) {
+-      trim_right_edge(dstinfo);
+-      trim_bottom_edge(dstinfo);
+-    }
+-    break;
+   case JXFORM_ROT_270:
+     transpose_critical_parameters(dstinfo);
+-    if (info->trim)
+-      trim_bottom_edge(dstinfo);
+     break;
+   }
+ 
++  /* Adjust Exif properties */
++  if (srcinfo->marker_list != NULL &&
++      srcinfo->marker_list->marker == JPEG_APP0+1 &&
++      srcinfo->marker_list->data_length >= 6 &&
++      GETJOCTET(srcinfo->marker_list->data[0]) == 0x45 &&
++      GETJOCTET(srcinfo->marker_list->data[1]) == 0x78 &&
++      GETJOCTET(srcinfo->marker_list->data[2]) == 0x69 &&
++      GETJOCTET(srcinfo->marker_list->data[3]) == 0x66 &&
++      GETJOCTET(srcinfo->marker_list->data[4]) == 0 &&
++      GETJOCTET(srcinfo->marker_list->data[5]) == 0) {
++    /* Suppress output of JFIF marker */
++    dstinfo->write_JFIF_header = FALSE;
++    /* Adjust Exif image parameters */
++    if (dstinfo->image_width != srcinfo->image_width ||
++	dstinfo->image_height != srcinfo->image_height)
++      /* Align data segment to start of TIFF structure for parsing */
++      adjust_exif_parameters(srcinfo->marker_list->data + 6,
++	srcinfo->marker_list->data_length - 6,
++	dstinfo->image_width, dstinfo->image_height);
++  }
++
+   /* Return the appropriate output data set */
+   if (info->workspace_coef_arrays != NULL)
+     return info->workspace_coef_arrays;
+@@ -816,38 +1349,106 @@
+  */
+ 
+ GLOBAL(void)
+-jtransform_execute_transformation (j_decompress_ptr srcinfo,
+-				   j_compress_ptr dstinfo,
+-				   jvirt_barray_ptr *src_coef_arrays,
+-				   jpeg_transform_info *info)
++jtransform_execute_transform (j_decompress_ptr srcinfo,
++			      j_compress_ptr dstinfo,
++			      jvirt_barray_ptr *src_coef_arrays,
++			      jpeg_transform_info *info)
+ {
+   jvirt_barray_ptr *dst_coef_arrays = info->workspace_coef_arrays;
+ 
++  /* Note: conditions tested here should match those in switch statement
++   * in jtransform_request_workspace()
++   */
+   switch (info->transform) {
+   case JXFORM_NONE:
++    if (info->x_crop_offset != 0 || info->y_crop_offset != 0)
++      do_crop(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
++	      src_coef_arrays, dst_coef_arrays);
+     break;
+   case JXFORM_FLIP_H:
+-    do_flip_h(srcinfo, dstinfo, src_coef_arrays);
++    if (info->y_crop_offset != 0)
++      do_flip_h(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
++		src_coef_arrays, dst_coef_arrays);
++    else
++      do_flip_h_no_crop(srcinfo, dstinfo, info->x_crop_offset,
++			src_coef_arrays);
+     break;
+   case JXFORM_FLIP_V:
+-    do_flip_v(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
++    do_flip_v(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
++	      src_coef_arrays, dst_coef_arrays);
+     break;
+   case JXFORM_TRANSPOSE:
+-    do_transpose(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
++    do_transpose(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
++		 src_coef_arrays, dst_coef_arrays);
+     break;
+   case JXFORM_TRANSVERSE:
+-    do_transverse(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
++    do_transverse(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
++		  src_coef_arrays, dst_coef_arrays);
+     break;
+   case JXFORM_ROT_90:
+-    do_rot_90(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
++    do_rot_90(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
++	      src_coef_arrays, dst_coef_arrays);
+     break;
+   case JXFORM_ROT_180:
+-    do_rot_180(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
++    do_rot_180(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
++	       src_coef_arrays, dst_coef_arrays);
+     break;
+   case JXFORM_ROT_270:
+-    do_rot_270(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
++    do_rot_270(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
++	       src_coef_arrays, dst_coef_arrays);
++    break;
++  }
++}
++
++/* jtransform_perfect_transform
++ *
++ * Determine whether lossless transformation is perfectly
++ * possible for a specified image and transformation.
++ *
++ * Inputs:
++ *   image_width, image_height: source image dimensions.
++ *   MCU_width, MCU_height: pixel dimensions of MCU.
++ *   transform: transformation identifier.
++ * Parameter sources from initialized jpeg_struct
++ * (after reading source header):
++ *   image_width = cinfo.image_width
++ *   image_height = cinfo.image_height
++ *   MCU_width = cinfo.max_h_samp_factor * DCTSIZE
++ *   MCU_height = cinfo.max_v_samp_factor * DCTSIZE
++ * Result:
++ *   TRUE = perfect transformation possible
++ *   FALSE = perfect transformation not possible
++ *           (may use custom action then)
++ */
++
++GLOBAL(boolean)
++jtransform_perfect_transform(JDIMENSION image_width, JDIMENSION image_height,
++			     int MCU_width, int MCU_height,
++			     JXFORM_CODE transform)
++{
++  boolean result = TRUE; /* initialize TRUE */
++
++  switch (transform) {
++  case JXFORM_FLIP_H:
++  case JXFORM_ROT_270:
++    if (image_width % (JDIMENSION) MCU_width)
++      result = FALSE;
++    break;
++  case JXFORM_FLIP_V:
++  case JXFORM_ROT_90:
++    if (image_height % (JDIMENSION) MCU_height)
++      result = FALSE;
++    break;
++  case JXFORM_TRANSVERSE:
++  case JXFORM_ROT_180:
++    if (image_width % (JDIMENSION) MCU_width)
++      result = FALSE;
++    if (image_height % (JDIMENSION) MCU_height)
++      result = FALSE;
+     break;
+   }
++
++  return result;
+ }
+ 
+ #endif /* TRANSFORMS_SUPPORTED */
+diff -urNad /home/bill/debian/libjpeg/libjpeg6b-6b/transupp.h libjpeg6b-6b/transupp.h
+--- /home/bill/debian/libjpeg/libjpeg6b-6b/transupp.h	2003-09-22 18:15:49.000000000 +0200
++++ libjpeg6b-6b/transupp.h	2003-09-22 18:16:16.000000000 +0200
+@@ -1,7 +1,7 @@
+ /*
+  * transupp.h
+  *
+- * Copyright (C) 1997, Thomas G. Lane.
++ * Copyright (C) 1997-2001, Thomas G. Lane.
+  * This file is part of the Independent JPEG Group's software.
+  * For conditions of distribution and use, see the accompanying README file.
+  *
+@@ -22,32 +22,6 @@
+ #define TRANSFORMS_SUPPORTED 1		/* 0 disables transform code */
+ #endif
+ 
+-/* Short forms of external names for systems with brain-damaged linkers. */
+-
+-#ifdef NEED_SHORT_EXTERNAL_NAMES
+-#define jtransform_request_workspace		jTrRequest
+-#define jtransform_adjust_parameters		jTrAdjust
+-#define jtransform_execute_transformation	jTrExec
+-#define jcopy_markers_setup			jCMrkSetup
+-#define jcopy_markers_execute			jCMrkExec
+-#endif /* NEED_SHORT_EXTERNAL_NAMES */
+-
+-
+-/*
+- * Codes for supported types of image transformations.
+- */
+-
+-typedef enum {
+-	JXFORM_NONE,		/* no transformation */
+-	JXFORM_FLIP_H,		/* horizontal flip */
+-	JXFORM_FLIP_V,		/* vertical flip */
+-	JXFORM_TRANSPOSE,	/* transpose across UL-to-LR axis */
+-	JXFORM_TRANSVERSE,	/* transpose across UR-to-LL axis */
+-	JXFORM_ROT_90,		/* 90-degree clockwise rotation */
+-	JXFORM_ROT_180,		/* 180-degree rotation */
+-	JXFORM_ROT_270		/* 270-degree clockwise (or 90 ccw) */
+-} JXFORM_CODE;
+-
+ /*
+  * Although rotating and flipping data expressed as DCT coefficients is not
+  * hard, there is an asymmetry in the JPEG format specification for images
+@@ -75,6 +49,19 @@
+  * (For example, -rot 270 -trim trims only the bottom edge, but -rot 90 -trim
+  * followed by -rot 180 -trim trims both edges.)
+  *
++ * We also offer a lossless-crop option, which discards data outside a given
++ * image region but losslessly preserves what is inside.  Like the rotate and
++ * flip transforms, lossless crop is restricted by the JPEG format: the upper
++ * left corner of the selected region must fall on an iMCU boundary.  If this
++ * does not hold for the given crop parameters, we silently move the upper left
++ * corner up and/or left to make it so, simultaneously increasing the region
++ * dimensions to keep the lower right crop corner unchanged.  (Thus, the
++ * output image covers at least the requested region, but may cover more.)
++ *
++ * If both crop and a rotate/flip transform are requested, the crop is applied
++ * last --- that is, the crop region is specified in terms of the destination
++ * image.
++ *
+  * We also offer a "force to grayscale" option, which simply discards the
+  * chrominance channels of a YCbCr image.  This is lossless in the sense that
+  * the luminance channel is preserved exactly.  It's not the same kind of
+@@ -83,20 +70,89 @@
+  * be aware of the option to know how many components to work on.
+  */
+ 
++
++/* Short forms of external names for systems with brain-damaged linkers. */
++
++#ifdef NEED_SHORT_EXTERNAL_NAMES
++#define jtransform_parse_crop_spec	jTrParCrop
++#define jtransform_request_workspace	jTrRequest
++#define jtransform_adjust_parameters	jTrAdjust
++#define jtransform_execute_transform	jTrExec
++#define jtransform_perfect_transform	jTrPerfect
++#define jcopy_markers_setup		jCMrkSetup
++#define jcopy_markers_execute		jCMrkExec
++#endif /* NEED_SHORT_EXTERNAL_NAMES */
++
++
++/*
++ * Codes for supported types of image transformations.
++ */
++
++typedef enum {
++	JXFORM_NONE,		/* no transformation */
++	JXFORM_FLIP_H,		/* horizontal flip */
++	JXFORM_FLIP_V,		/* vertical flip */
++	JXFORM_TRANSPOSE,	/* transpose across UL-to-LR axis */
++	JXFORM_TRANSVERSE,	/* transpose across UR-to-LL axis */
++	JXFORM_ROT_90,		/* 90-degree clockwise rotation */
++	JXFORM_ROT_180,		/* 180-degree rotation */
++	JXFORM_ROT_270		/* 270-degree clockwise (or 90 ccw) */
++} JXFORM_CODE;
++
++/*
++ * Codes for crop parameters, which can individually be unspecified,
++ * positive, or negative.  (Negative width or height makes no sense, though.)
++ */
++
++typedef enum {
++	JCROP_UNSET,
++	JCROP_POS,
++	JCROP_NEG
++} JCROP_CODE;
++
++/*
++ * Transform parameters struct.
++ * NB: application must not change any elements of this struct after
++ * calling jtransform_request_workspace.
++ */
++
+ typedef struct {
+   /* Options: set by caller */
+   JXFORM_CODE transform;	/* image transform operator */
++  boolean perfect;		/* if TRUE, fail if partial MCUs are requested */
+   boolean trim;			/* if TRUE, trim partial MCUs as needed */
+   boolean force_grayscale;	/* if TRUE, convert color image to grayscale */
++  boolean crop;			/* if TRUE, crop source image */
++
++  /* Crop parameters: application need not set these unless crop is TRUE.
++   * These can be filled in by jtransform_parse_crop_spec().
++   */
++  JDIMENSION crop_width;	/* Width of selected region */
++  JCROP_CODE crop_width_set;
++  JDIMENSION crop_height;	/* Height of selected region */
++  JCROP_CODE crop_height_set;
++  JDIMENSION crop_xoffset;	/* X offset of selected region */
++  JCROP_CODE crop_xoffset_set;	/* (negative measures from right edge) */
++  JDIMENSION crop_yoffset;	/* Y offset of selected region */
++  JCROP_CODE crop_yoffset_set;	/* (negative measures from bottom edge) */
+ 
+   /* Internal workspace: caller should not touch these */
+   int num_components;		/* # of components in workspace */
+   jvirt_barray_ptr * workspace_coef_arrays; /* workspace for transformations */
++  JDIMENSION output_width;	/* cropped destination dimensions */
++  JDIMENSION output_height;
++  JDIMENSION x_crop_offset;	/* destination crop offsets measured in iMCUs */
++  JDIMENSION y_crop_offset;
++  int max_h_samp_factor;	/* destination iMCU size */
++  int max_v_samp_factor;
+ } jpeg_transform_info;
+ 
+ 
+ #if TRANSFORMS_SUPPORTED
+ 
++/* Parse a crop specification (written in X11 geometry style) */
++EXTERN(boolean) jtransform_parse_crop_spec
++	JPP((jpeg_transform_info *info, const char *spec));
+ /* Request any required workspace */
+ EXTERN(void) jtransform_request_workspace
+ 	JPP((j_decompress_ptr srcinfo, jpeg_transform_info *info));
+@@ -106,10 +162,24 @@
+ 	     jvirt_barray_ptr *src_coef_arrays,
+ 	     jpeg_transform_info *info));
+ /* Execute the actual transformation, if any */
+-EXTERN(void) jtransform_execute_transformation
++EXTERN(void) jtransform_execute_transform
+ 	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+ 	     jvirt_barray_ptr *src_coef_arrays,
+ 	     jpeg_transform_info *info));
++/* Determine whether lossless transformation is perfectly
++ * possible for a specified image and transformation.
++ */
++EXTERN(boolean) jtransform_perfect_transform
++	JPP((JDIMENSION image_width, JDIMENSION image_height,
++	     int MCU_width, int MCU_height,
++	     JXFORM_CODE transform));
++
++/* jtransform_execute_transform used to be called
++ * jtransform_execute_transformation, but some compilers complain about
++ * routine names that long.  This macro is here to avoid breaking any
++ * old source code that uses the original name...
++ */
++#define jtransform_execute_transformation	jtransform_execute_transform
+ 
+ #endif /* TRANSFORMS_SUPPORTED */
+ 
--- libjpeg6b-6b.orig/debian/patches/203_rdppm.dpatch
+++ libjpeg6b-6b/debian/patches/203_rdppm.dpatch
@@ -0,0 +1,59 @@
+#!/bin/sh -e
+## debian/patches/203_rdppm.dpatch by Bill Allombert <ballombe@debian.org>
+##
+## DP: Fix byte order issue with 16bit PPM/PGM files in rdppm.c
+
+if [ $# -ne 1 ]; then
+    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+    exit 1
+fi
+
+[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
+patch_opts="${patch_opts:--f --no-backup-if-mismatch}"
+
+case "$1" in
+       -patch) patch $patch_opts -p1 < $0;;
+       -unpatch) patch $patch_opts -p1 -R < $0;;
+        *)
+                echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+                exit 1;;
+esac
+
+exit 0
+
+@DPATCH@
+diff -urNad /home/bill/debian/libjpeg/libjpeg6b-6b/rdppm.c libjpeg6b-6b/rdppm.c
+--- /home/bill/debian/libjpeg/libjpeg6b-6b/rdppm.c	2003-09-08 16:44:20.000000000 +0200
++++ libjpeg6b-6b/rdppm.c	2003-09-08 16:47:19.000000000 +0200
+@@ -250,8 +250,8 @@
+   bufferptr = source->iobuffer;
+   for (col = cinfo->image_width; col > 0; col--) {
+     register int temp;
+-    temp  = UCH(*bufferptr++);
+-    temp |= UCH(*bufferptr++) << 8;
++    temp  = UCH(*bufferptr++) << 8;
++    temp |= UCH(*bufferptr++);
+     *ptr++ = rescale[temp];
+   }
+   return 1;
+@@ -274,14 +274,14 @@
+   bufferptr = source->iobuffer;
+   for (col = cinfo->image_width; col > 0; col--) {
+     register int temp;
+-    temp  = UCH(*bufferptr++);
+-    temp |= UCH(*bufferptr++) << 8;
++    temp  = UCH(*bufferptr++) << 8;
++    temp |= UCH(*bufferptr++);
+     *ptr++ = rescale[temp];
+-    temp  = UCH(*bufferptr++);
+-    temp |= UCH(*bufferptr++) << 8;
++    temp  = UCH(*bufferptr++) << 8;
++    temp |= UCH(*bufferptr++);
+     *ptr++ = rescale[temp];
+-    temp  = UCH(*bufferptr++);
+-    temp |= UCH(*bufferptr++) << 8;
++    temp  = UCH(*bufferptr++) << 8;
++    temp |= UCH(*bufferptr++);
+     *ptr++ = rescale[temp];
+   }
+   return 1;
--- libjpeg6b-6b.orig/debian/patches/201_rdjpgcom_locale.dpatch
+++ libjpeg6b-6b/debian/patches/201_rdjpgcom_locale.dpatch
@@ -0,0 +1,44 @@
+#! /bin/sh -e
+
+# DP: Make rdjpegcom locale aware.
+
+case "$1" in
+    -patch) patch -f --no-backup-if-mismatch -p1 < $0;;
+    -unpatch) patch -f --no-backup-if-mismatch -R -p1 < $0;;
+    *)
+        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+        exit 1
+esac
+exit 0
+@DPATCH@
+--- jpeg-6b/rdjpgcom.c	Sun Oct 12 00:41:04 1997
++++ libjpeg6b-6b/rdjpgcom.c	Wed Feb 26 01:04:42 2003
+@@ -14,6 +14,7 @@
+ #define JPEG_CJPEG_DJPEG	/* to get the command-line config symbols */
+ #include "jinclude.h"		/* get auto-config symbols, <stdio.h> */
+ 
++#include <locale.h>             /*ballombe@debian.org: use locale for isprint*/
+ #include <ctype.h>		/* to declare isupper(), tolower() */
+ #ifdef USE_SETMODE
+ #include <fcntl.h>		/* to declare setmode()'s parameter macros */
+@@ -223,7 +224,10 @@
+   unsigned int length;
+   int ch;
+   int lastch = 0;
+-
++/* ballombe@debian.org Thu, 15 Nov 2001 20:04:47 +0100*/
++/* Set locale properly for isprint*/
++  setlocale(LC_CTYPE,"");
++    
+   /* Get the marker parameter length count */
+   length = read_2_bytes();
+   /* Length includes itself, so must be at least 2 */
+@@ -254,6 +258,8 @@
+     length--;
+   }
+   printf("\n");
++/*ballombe@debian.org: revert to C locale*/
++  setlocale(LC_CTYPE,"C");
+ }
+ 
+ 
--- libjpeg6b-6b.orig/debian/patches/204_jpegtran_man.dpatch
+++ libjpeg6b-6b/debian/patches/204_jpegtran_man.dpatch
@@ -0,0 +1,106 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 204_jpegtran_man.dpatch by Jorgen Grahn <grahn+debian@snipabacken.dyndns.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: improves readability of jpegtran man page
+
+@DPATCH@
+diff -urNad libjpeg6b-6b~/jpegtran.1 libjpeg6b-6b/jpegtran.1
+--- libjpeg6b-6b~/jpegtran.1	2007-08-16 22:55:43.000000000 +0200
++++ libjpeg6b-6b/jpegtran.1	2007-08-16 22:55:50.000000000 +0200
+@@ -91,12 +91,12 @@
+ .TP
+ .B \-transverse
+ Transverse transpose (across UR-to-LL axis).
+-.PP
++.IP
+ The transpose transformation has no restrictions regarding image dimensions.
+ The other transformations operate rather oddly if the image dimensions are not
+ a multiple of the iMCU size (usually 8 or 16 pixels), because they can only
+ transform complete blocks of DCT coefficient data in the desired way.
+-.PP
++.IP
+ .BR jpegtran 's
+ default behavior when transforming an odd-size image is designed
+ to preserve exact reversibility and mathematical consistency of the
+@@ -108,7 +108,7 @@
+ of transpose and flip operations; for consistency, their actions on edge
+ pixels are defined to be the same as the end result of the corresponding
+ transpose-and-flip sequence.
+-.PP
++.IP
+ For practical use, you may prefer to discard any untransformable edge pixels
+ rather than having a strange-looking strip along the right and/or bottom edges
+ of a transformed image.  To do this, add the
+@@ -117,7 +117,7 @@
+ .TP
+ .B \-trim
+ Drop non-transformable edge blocks.
+-.PP
++.IP
+ Obviously, a transformation with
+ .B \-trim
+ is not reversible, so strictly speaking
+@@ -130,7 +130,7 @@
+ followed by
+ .B \-rot 180 -trim
+ trims both edges.
+-.PP
++.IP
+ If you are only interested by perfect transformation, add the
+ .B \-perfect
+ switch:
+@@ -138,8 +138,9 @@
+ .B \-perfect
+ Fails with an error if the transformation is not perfect. For example
+ you may want to do
+-.TP
++.IP
+ .B (jpegtran \-rot 90 -perfect foo.jpg || djpeg foo.jpg| pnmflip \-r90 | cjpeg)
++.IP
+ to do a perfect rotation if available or an approximated one if
+ not.
+ .PP
+@@ -151,25 +152,24 @@
+ corner up and/or left to make it so, simultaneously increasing the region
+ dimensions to keep the lower right crop corner unchanged.  (Thus, the
+ output image covers at least the requested region, but may cover more.)
+-
++.IP
+ Note: 
+ .B \-perfect
+ and
+ .B lossless-crop
+ are enhancements from http://sylvana.net/jpegcrop/ that may not be available on
+ non-Debian systems.
+-
++.PP
+ The image can be losslessly cropped by giving the switch:
+ .TP
+ .B \-crop WxH+X+Y
+ Crop to a rectangular subarea of width W, height H starting at point X,Y.
+ .PP
+-.PP
+ Another not-strictly-lossless transformation switch is:
+ .TP
+ .B \-grayscale
+ Force grayscale output.
+-.PP
++.IP
+ This option discards the chrominance channels if the input image is YCbCr
+ (ie, a standard color JPEG), resulting in a grayscale JPEG file.  The
+ luminance channel is preserved exactly, so this is a better method of reducing
+@@ -193,9 +193,11 @@
+ .TP
+ .B \-copy all
+ Copy all extra markers.  This setting preserves miscellaneous markers
+-found in the source file, such as JFIF thumbnails and Photoshop settings.
++found in the source file, such as
++Exif data,
++JFIF thumbnails and Photoshop settings.
+ In some files these extra markers can be sizable.
+-.PP
++.IP
+ The default behavior is
+ .BR "\-copy comments" .
+ (Note: in IJG releases v6 and v6a,
--- libjpeg6b-6b.orig/debian/patches/00list
+++ libjpeg6b-6b/debian/patches/00list
@@ -0,0 +1,7 @@
+100_crop
+200_crop_man
+201_rdjpgcom_locale
+202_jpeglib.h_c++
+203_rdppm
+204_jpegtran_man
+300_config.sub
--- libjpeg6b-6b.orig/debian/patches/200_crop_man.dpatch
+++ libjpeg6b-6b/debian/patches/200_crop_man.dpatch
@@ -0,0 +1,68 @@
+#! /bin/sh -e
+
+# DP: Manpage update for jpegtran -crop
+
+case "$1" in
+    -patch) patch -f --no-backup-if-mismatch -p1 < $0;;
+    -unpatch) patch -f --no-backup-if-mismatch -R -p1 < $0;;
+    *)
+        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+        exit 1
+esac
+exit 0
+@DPATCH@
+diff -urNad /home/bill/debian/libjpeg/libjpeg6b-6b/jpegtran.1 libjpeg6b-6b/jpegtran.1
+--- /home/bill/debian/libjpeg/libjpeg6b-6b/jpegtran.1	2003-09-22 18:46:08.000000000 +0200
++++ libjpeg6b-6b/jpegtran.1	2003-09-22 18:49:06.000000000 +0200
+@@ -131,6 +131,40 @@
+ .B \-rot 180 -trim
+ trims both edges.
+ .PP
++If you are only interested by perfect transformation, add the
++.B \-perfect
++switch:
++.TP
++.B \-perfect
++Fails with an error if the transformation is not perfect. For example
++you may want to do
++.TP
++.B (jpegtran \-rot 90 -perfect foo.jpg || djpeg foo.jpg| pnmflip \-r90 | cjpeg)
++to do a perfect rotation if available or an approximated one if
++not.
++.PP
++We also offer a lossless-crop option, which discards data outside a given
++image region but losslessly preserves what is inside.  Like the rotate and
++flip transforms, lossless crop is restricted by the JPEG format: the upper
++left corner of the selected region must fall on an iMCU boundary.  If this
++does not hold for the given crop parameters, we silently move the upper left
++corner up and/or left to make it so, simultaneously increasing the region
++dimensions to keep the lower right crop corner unchanged.  (Thus, the
++output image covers at least the requested region, but may cover more.)
++
++Note: 
++.B \-perfect
++and
++.B lossless-crop
++are enhancements from http://sylvana.net/jpegcrop/ that may not be available on
++non-Debian systems.
++
++The image can be losslessly cropped by giving the switch:
++.TP
++.B \-crop WxH+X+Y
++Crop to a rectangular subarea of width W, height H starting at point X,Y.
++.PP
++.PP
+ Another not-strictly-lossless transformation switch is:
+ .TP
+ .B \-grayscale
+@@ -231,7 +265,9 @@
+ .PP
+ The transform options can't transform odd-size images perfectly.  Use
+ .B \-trim
+-if you don't like the results without it.
++or
++.B \-perfect
++if you don't like the results.
+ .PP
+ The entire image is read into memory and then written out again, even in
+ cases where this isn't really necessary.  Expect swapping on large images,
--- libjpeg6b-6b.orig/debian/patches/300_config.sub.dpatch
+++ libjpeg6b-6b/debian/patches/300_config.sub.dpatch
@@ -0,0 +1,39 @@
+#! /bin/sh -e
+
+# DP: Fix config.{sub,guess} to use autotools-dev version.
+
+case "$1" in
+    -patch) patch -f --no-backup-if-mismatch -p1 < $0;;
+    -unpatch) patch -f --no-backup-if-mismatch -R -p1 < $0;;
+    *)
+        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+        exit 1
+esac
+exit 0
+@DPATCH@
+--- jpeg-6b/config.guess	Wed Mar 25 16:25:38 1998
++++ libjpeg6b-6b/config.guess	Wed Feb 26 01:04:42 2003
+@@ -1,4 +1,10 @@
+ #! /bin/sh
++# autotools-dev hack (<ballombe@debian.org>, Wed, 14 Nov 2001 10:13:10 +0100)
++if [ -x /usr/share/misc/config.guess ]; then
++   /usr/share/misc/config.guess $*
++   exit $?
++fi
++
+ # Attempt to guess a canonical system name.
+ #   Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
+ #
+--- jpeg-6b/config.sub	Wed Mar 25 16:25:39 1998
++++ libjpeg6b-6b/config.sub	Wed Feb 26 01:04:42 2003
+@@ -1,4 +1,10 @@
+ #! /bin/sh
++# autotools-dev hack (<ballombe@debian.org>, Wed, 14 Nov 2001 10:13:10 +0100)
++if [ -x /usr/share/misc/config.sub ]; then
++   /usr/share/misc/config.sub $*
++   exit $?
++fi
++
+ # Configuration validation subroutine script, version 1.1.
+ #   Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
+ # This file is (in principle) common to ALL GNU software.
--- libjpeg6b-6b.orig/debian/patched/202_jpeglib.h_c++.dpatch
+++ libjpeg6b-6b/debian/patched/202_jpeglib.h_c++.dpatch
@@ -0,0 +1 @@
+patching file jpeglib.h
--- libjpeg6b-6b.orig/debian/patched/100_crop.dpatch
+++ libjpeg6b-6b/debian/patched/100_crop.dpatch
@@ -0,0 +1,4 @@
+patching file jerror.h
+patching file jpegtran.c
+patching file transupp.c
+patching file transupp.h
--- libjpeg6b-6b.orig/debian/patched/203_rdppm.dpatch
+++ libjpeg6b-6b/debian/patched/203_rdppm.dpatch
@@ -0,0 +1 @@
+patching file rdppm.c
--- libjpeg6b-6b.orig/debian/patched/201_rdjpgcom_locale.dpatch
+++ libjpeg6b-6b/debian/patched/201_rdjpgcom_locale.dpatch
@@ -0,0 +1 @@
+patching file rdjpgcom.c
--- libjpeg6b-6b.orig/debian/patched/204_jpegtran_man.dpatch
+++ libjpeg6b-6b/debian/patched/204_jpegtran_man.dpatch
@@ -0,0 +1 @@
+patching file jpegtran.1
--- libjpeg6b-6b.orig/debian/patched/200_crop_man.dpatch
+++ libjpeg6b-6b/debian/patched/200_crop_man.dpatch
@@ -0,0 +1 @@
+patching file jpegtran.1
--- libjpeg6b-6b.orig/debian/patched/300_config.sub.dpatch
+++ libjpeg6b-6b/debian/patched/300_config.sub.dpatch
@@ -0,0 +1,2 @@
+patching file config.guess
+patching file config.sub
--- libjpeg6b-6b.orig/debian/copyright
+++ libjpeg6b-6b/debian/copyright
@@ -0,0 +1,96 @@
+This is Debian's prepackaged version of the `jpeg library' by the Independent
+JPEG Group.
+
+This package was created by Mark Mickan <mmickan@debian.org> from sources
+which can be found at ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz
+
+It is partly based on the libjpeg6a package originally put together by
+Andy Guy <awpguy@acs.ucalgary.ca> and later maintained by Mark Mickan.
+
+Current Debian maintainer is Bill Allombert <ballombe@debian.org>.
+
+LEGAL ISSUES [ from README supplied with source - MM ]
+============
+
+In plain English:
+
+1. We don't promise that this software works.  (But if you find any bugs,
+   please let us know!)
+2. You can use this software for whatever you want.  You don't have to pay us.
+3. You may not pretend that you wrote this software.  If you use it in a
+   program, you must acknowledge somewhere in your documentation that
+   you've used the IJG code.
+
+In legalese:
+
+The authors make NO WARRANTY or representation, either express or implied,
+with respect to this software, its quality, accuracy, merchantability, or
+fitness for a particular purpose.  This software is provided "AS IS", and you,
+its user, assume the entire risk as to its quality and accuracy.
+
+This software is copyright (C) 1991-1998, Thomas G. Lane.
+All Rights Reserved except as specified below.
+
+Permission is hereby granted to use, copy, modify, and distribute this
+software (or portions thereof) for any purpose, without fee, subject to these
+conditions:
+(1) If any part of the source code for this software is distributed, then this
+README file must be included, with this copyright and no-warranty notice
+unaltered; and any additions, deletions, or changes to the original files
+must be clearly indicated in accompanying documentation.
+(2) If only executable code is distributed, then the accompanying
+documentation must state that "this software is based in part on the work of
+the Independent JPEG Group".
+(3) Permission for use of this software is granted only if the user accepts
+full responsibility for any undesirable consequences; the authors accept
+NO LIABILITY for damages of any kind.
+
+These conditions apply to any software derived from or based on the IJG code,
+not just to the unmodified library.  If you use our work, you ought to
+acknowledge us.
+
+Permission is NOT granted for the use of any IJG author's name or company name
+in advertising or publicity relating to this software or products derived from
+it.  This software may be referred to only as "the Independent JPEG Group's
+software".
+
+We specifically permit and encourage the use of this software as the basis of
+commercial products, provided that all warranty or liability claims are
+assumed by the product vendor.
+
+
+ansi2knr.c is included in this distribution by permission of L. Peter Deutsch,
+sole proprietor of its copyright holder, Aladdin Enterprises of Menlo Park, CA.
+ansi2knr.c is NOT covered by the above copyright and conditions, but instead
+by the usual distribution terms of the Free Software Foundation; principally,
+that you must include source code if you redistribute it.  (See the file
+ansi2knr.c for full details.)  However, since ansi2knr.c is not needed as part
+of any program generated from the IJG code, this does not limit you more than
+the foregoing paragraphs do.
+
+The Unix configuration script "configure" was produced with GNU Autoconf.
+It is copyright by the Free Software Foundation but is freely distributable.
+The same holds for its supporting scripts (config.guess, config.sub,
+ltconfig, ltmain.sh).  Another support script, install-sh, is copyright
+by M.I.T. but is also freely distributable.
+
+It appears that the arithmetic coding option of the JPEG spec is covered by
+patents owned by IBM, AT&T, and Mitsubishi.  Hence arithmetic coding cannot
+legally be used without obtaining one or more licenses.  For this reason,
+support for arithmetic coding has been removed from the free JPEG software.
+(Since arithmetic coding provides only a marginal gain over the unpatented
+Huffman mode, it is unlikely that very many implementations will support it.)
+So far as we are aware, there are no patent restrictions on the remaining
+code.
+
+The IJG distribution formerly included code to read and write GIF files.
+To avoid entanglement with the Unisys LZW patent, GIF reading support has
+been removed altogether, and the GIF writer has been simplified to produce
+"uncompressed GIFs".  This technique does not use the LZW algorithm; the
+resulting GIF files are larger than usual, but are readable by all standard
+GIF decoders.
+
+We are required to state that
+    "The Graphics Interchange Format(c) is the Copyright property of
+    CompuServe Incorporated.  GIF(sm) is a Service Mark property of
+    CompuServe Incorporated."
--- libjpeg6b-6b.orig/transupp.h
+++ libjpeg6b-6b/transupp.h
@@ -1,7 +1,7 @@
 /*
  * transupp.h
  *
- * Copyright (C) 1997, Thomas G. Lane.
+ * Copyright (C) 1997-2001, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
@@ -22,32 +22,6 @@
 #define TRANSFORMS_SUPPORTED 1		/* 0 disables transform code */
 #endif
 
-/* Short forms of external names for systems with brain-damaged linkers. */
-
-#ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jtransform_request_workspace		jTrRequest
-#define jtransform_adjust_parameters		jTrAdjust
-#define jtransform_execute_transformation	jTrExec
-#define jcopy_markers_setup			jCMrkSetup
-#define jcopy_markers_execute			jCMrkExec
-#endif /* NEED_SHORT_EXTERNAL_NAMES */
-
-
-/*
- * Codes for supported types of image transformations.
- */
-
-typedef enum {
-	JXFORM_NONE,		/* no transformation */
-	JXFORM_FLIP_H,		/* horizontal flip */
-	JXFORM_FLIP_V,		/* vertical flip */
-	JXFORM_TRANSPOSE,	/* transpose across UL-to-LR axis */
-	JXFORM_TRANSVERSE,	/* transpose across UR-to-LL axis */
-	JXFORM_ROT_90,		/* 90-degree clockwise rotation */
-	JXFORM_ROT_180,		/* 180-degree rotation */
-	JXFORM_ROT_270		/* 270-degree clockwise (or 90 ccw) */
-} JXFORM_CODE;
-
 /*
  * Although rotating and flipping data expressed as DCT coefficients is not
  * hard, there is an asymmetry in the JPEG format specification for images
@@ -75,6 +49,19 @@
  * (For example, -rot 270 -trim trims only the bottom edge, but -rot 90 -trim
  * followed by -rot 180 -trim trims both edges.)
  *
+ * We also offer a lossless-crop option, which discards data outside a given
+ * image region but losslessly preserves what is inside.  Like the rotate and
+ * flip transforms, lossless crop is restricted by the JPEG format: the upper
+ * left corner of the selected region must fall on an iMCU boundary.  If this
+ * does not hold for the given crop parameters, we silently move the upper left
+ * corner up and/or left to make it so, simultaneously increasing the region
+ * dimensions to keep the lower right crop corner unchanged.  (Thus, the
+ * output image covers at least the requested region, but may cover more.)
+ *
+ * If both crop and a rotate/flip transform are requested, the crop is applied
+ * last --- that is, the crop region is specified in terms of the destination
+ * image.
+ *
  * We also offer a "force to grayscale" option, which simply discards the
  * chrominance channels of a YCbCr image.  This is lossless in the sense that
  * the luminance channel is preserved exactly.  It's not the same kind of
@@ -83,20 +70,89 @@
  * be aware of the option to know how many components to work on.
  */
 
+
+/* Short forms of external names for systems with brain-damaged linkers. */
+
+#ifdef NEED_SHORT_EXTERNAL_NAMES
+#define jtransform_parse_crop_spec	jTrParCrop
+#define jtransform_request_workspace	jTrRequest
+#define jtransform_adjust_parameters	jTrAdjust
+#define jtransform_execute_transform	jTrExec
+#define jtransform_perfect_transform	jTrPerfect
+#define jcopy_markers_setup		jCMrkSetup
+#define jcopy_markers_execute		jCMrkExec
+#endif /* NEED_SHORT_EXTERNAL_NAMES */
+
+
+/*
+ * Codes for supported types of image transformations.
+ */
+
+typedef enum {
+	JXFORM_NONE,		/* no transformation */
+	JXFORM_FLIP_H,		/* horizontal flip */
+	JXFORM_FLIP_V,		/* vertical flip */
+	JXFORM_TRANSPOSE,	/* transpose across UL-to-LR axis */
+	JXFORM_TRANSVERSE,	/* transpose across UR-to-LL axis */
+	JXFORM_ROT_90,		/* 90-degree clockwise rotation */
+	JXFORM_ROT_180,		/* 180-degree rotation */
+	JXFORM_ROT_270		/* 270-degree clockwise (or 90 ccw) */
+} JXFORM_CODE;
+
+/*
+ * Codes for crop parameters, which can individually be unspecified,
+ * positive, or negative.  (Negative width or height makes no sense, though.)
+ */
+
+typedef enum {
+	JCROP_UNSET,
+	JCROP_POS,
+	JCROP_NEG
+} JCROP_CODE;
+
+/*
+ * Transform parameters struct.
+ * NB: application must not change any elements of this struct after
+ * calling jtransform_request_workspace.
+ */
+
 typedef struct {
   /* Options: set by caller */
   JXFORM_CODE transform;	/* image transform operator */
+  boolean perfect;		/* if TRUE, fail if partial MCUs are requested */
   boolean trim;			/* if TRUE, trim partial MCUs as needed */
   boolean force_grayscale;	/* if TRUE, convert color image to grayscale */
+  boolean crop;			/* if TRUE, crop source image */
+
+  /* Crop parameters: application need not set these unless crop is TRUE.
+   * These can be filled in by jtransform_parse_crop_spec().
+   */
+  JDIMENSION crop_width;	/* Width of selected region */
+  JCROP_CODE crop_width_set;
+  JDIMENSION crop_height;	/* Height of selected region */
+  JCROP_CODE crop_height_set;
+  JDIMENSION crop_xoffset;	/* X offset of selected region */
+  JCROP_CODE crop_xoffset_set;	/* (negative measures from right edge) */
+  JDIMENSION crop_yoffset;	/* Y offset of selected region */
+  JCROP_CODE crop_yoffset_set;	/* (negative measures from bottom edge) */
 
   /* Internal workspace: caller should not touch these */
   int num_components;		/* # of components in workspace */
   jvirt_barray_ptr * workspace_coef_arrays; /* workspace for transformations */
+  JDIMENSION output_width;	/* cropped destination dimensions */
+  JDIMENSION output_height;
+  JDIMENSION x_crop_offset;	/* destination crop offsets measured in iMCUs */
+  JDIMENSION y_crop_offset;
+  int max_h_samp_factor;	/* destination iMCU size */
+  int max_v_samp_factor;
 } jpeg_transform_info;
 
 
 #if TRANSFORMS_SUPPORTED
 
+/* Parse a crop specification (written in X11 geometry style) */
+EXTERN(boolean) jtransform_parse_crop_spec
+	JPP((jpeg_transform_info *info, const char *spec));
 /* Request any required workspace */
 EXTERN(void) jtransform_request_workspace
 	JPP((j_decompress_ptr srcinfo, jpeg_transform_info *info));
@@ -106,10 +162,24 @@
 	     jvirt_barray_ptr *src_coef_arrays,
 	     jpeg_transform_info *info));
 /* Execute the actual transformation, if any */
-EXTERN(void) jtransform_execute_transformation
+EXTERN(void) jtransform_execute_transform
 	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
 	     jvirt_barray_ptr *src_coef_arrays,
 	     jpeg_transform_info *info));
+/* Determine whether lossless transformation is perfectly
+ * possible for a specified image and transformation.
+ */
+EXTERN(boolean) jtransform_perfect_transform
+	JPP((JDIMENSION image_width, JDIMENSION image_height,
+	     int MCU_width, int MCU_height,
+	     JXFORM_CODE transform));
+
+/* jtransform_execute_transform used to be called
+ * jtransform_execute_transformation, but some compilers complain about
+ * routine names that long.  This macro is here to avoid breaking any
+ * old source code that uses the original name...
+ */
+#define jtransform_execute_transformation	jtransform_execute_transform
 
 #endif /* TRANSFORMS_SUPPORTED */
 
--- libjpeg6b-6b.orig/patch-stamp
+++ libjpeg6b-6b/patch-stamp
@@ -0,0 +1,23 @@
+Patches applied in the Debian version of :
+
+debian/patches/100_crop.dpatch ():
+  Lossless-crop patch from <http://sylvana.net/jpegcrop/croppatch.tar.gz>
+  by <guido@jpegclub.org>.
+
+debian/patches/200_crop_man.dpatch ():
+  Manpage update for jpegtran -crop
+
+debian/patches/201_rdjpgcom_locale.dpatch ():
+  Make rdjpegcom locale aware.
+
+debian/patches/202_jpeglib.h_c++.dpatch ():
+  Add extern "C" to jpeglib.h
+
+debian/patches/203_rdppm.dpatch (Bill Allombert <ballombe@debian.org>):
+  Fix byte order issue with 16bit PPM/PGM files in rdppm.c
+
+debian/patches/204_jpegtran_man.dpatch (Jorgen Grahn <grahn+debian@snipabacken.dyndns.org>):
+  improves readability of jpegtran man page
+
+debian/patches/300_config.sub.dpatch ():
+  Fix config.{sub,guess} to use autotools-dev version.
